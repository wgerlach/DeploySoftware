#!/usr/bin/env perl

use strict;
use warnings;

use Cwd; #'abs_path getcwd'
use Getopt::Long;
use File::Basename;
eval "use JSON; 1"
or die "perl module required, e.g.: sudo apt-get install cpanminus ; sudo cpanm install JSON";

#use SHOCK::Client;

#use SHOCK::Client;

use File::Temp;
#use LWP::UserAgent;
use Data::Dumper;
#eval "use Try::Tiny; 1"
#or die "perl module required, e.g.: sudo apt-get install cpanminus ; sudo cpanm install Try::Tiny";

1;



my $default_repository = 'https://raw.github.com/wgerlach/SODOKU/master/merged-json/repository.json';

my $ubuntu_cmd2package = {
	'curl' => 'curl',
	'make' => 'make build-essential',
	'git' => 'git',
	'unzip' => 'unzip'
};


my $docker_base_image = 'ubuntu:13.10';
my $author = 'Wolfgang Gerlach';

my $shock_server = 'http://shock.metagenomics.anl.gov:80';


#########################################

my $target = undef;
my $data_target = undef;

my %already_installed;
my $h = {};

my $shock=undef;

my $shock_client_module_available = 0;

my $d=undef; # docker inidicator
my @docker_file_header=(
	'# This file was auto generated by SODOKU (github.com/wgerlach/SODOKU/)',
	'FROM '.$docker_base_image,
	'MAINTAINER '.$author,
	'RUN apt-get update'
	);
my @docker_file_content=();
my $docker_deps={};

my $is_root_user = undef;


sub createDockerFile {
	my ($package, $version) = @_;
	
	my $version_str = undef;
	if (defined $version) {
		$version_str = join('.', @{$version});
	}
	
	unless (defined $version_str) {
		$version_str = 'latest';
	}
	
	if ( $version_str eq '') {
		$version_str = 'latest';
	}
	
	print "deps: ".join(',', keys(%$docker_deps)) ."\n";
	
	my $dep_packages={};
	foreach my $dep (keys(%$docker_deps)) {
		my $pack = $ubuntu_cmd2package->{$dep};
		if (defined $pack) {
			$dep_packages->{$pack}=1;
		}
	}
	
	my $dockerfile='';
	
	$dockerfile .= join("\n", @docker_file_header)."\n";
	if (keys(%$dep_packages) > 0) {
		$dockerfile .= "RUN apt-get install -y ".join(' ', keys(%$dep_packages)) ."\n";
	}
	$dockerfile .= join("\n", @docker_file_content)."\n";
	
	print "------\nDockerfile\n";
	print $dockerfile;
	
	my $tag = 'wgerlach/'.$package.':'.$version_str;
	
	#print "tag: \"$tag\"\n";
	
	return [$tag, $dockerfile];
}


sub createDockerImage {
	
	my ($tag, $dockerfile) = @_;

		
	
	
	# check if image already exists
	
	my ($result_hash, $result_body) = dockerSocket('GET', "/images/$tag/json");
	
	my $image_id = undef;
	if (defined $result_hash) {
		$image_id = $result_hash->{'id'};
		unless (defined $image_id) {
			die "hash defined, but not id!?";
		}
		
		print Dumper($result_hash);
		print "image already exists:\n";
		print "ID: ".$image_id." $tag\n";
		
		unless (defined $h->{'docker_reuse_image'}) {
			print "to delete it run docker rmi ".$image_id."\n";
			exit(1);
		}
		
		
	}

	
	if (defined $result_body) {
		unless ($result_body =~ /inspect: No such image:/) {
			die "Error: Some error other than image not found: $result_body";
		}
	}
		
	
	
	
		
	
	### create docker image ###
	
	my $docker_build_cmd = 'docker build -q=true --no-cache=true --rm --tag='.$tag.' -';
	
	print "docker_build_cmd: $docker_build_cmd\n";
	
	
	
	
	unless (defined($h->{'docker_show_only'}) || defined($image_id) ) {
		open(my $fh, "|-", $docker_build_cmd)
			or die "cannot run docker: $!";
	
		print $fh $dockerfile;
		close ($fh);
		
		sleep(3);
		
		
		$result_hash = undef;
		$result_body = undef;
		($result_hash, $result_body) = dockerSocket('GET', "/images/$tag/json");
		
		
		if (defined $result_hash) {
			$image_id = $result_hash->{'id'};
						
		} else {
			die "result_hash not defined, docker image was not created !?";
		}
		
	}
	
	unless (defined $image_id) {
		die "image ID not found";
	}

	### save image as tar archive file
	
	my $tag_converted = $tag;
	$tag_converted =~ s/[\/]/\_/g;
	my $docker_base_image_converted = $docker_base_image;
	$docker_base_image_converted =~ s/[\/]/\_/g;
	my $image_tarfile = $image_id.'_'.$docker_base_image_converted.'_'.$tag_converted.'.tar';
	
	my $skip_saving = 0;
	
	
	if (defined $h->{'docker_reuse_image'}) {
		if (-e $image_tarfile) {
			$skip_saving = 1;
		}
	} else {
		if (-e $image_tarfile) {
			die "docker image file $image_tarfile already exists";
		}
	}
	
	if ($skip_saving == 0) {
		my $docker_save_cmd = 'docker save '.$image_id.' > '.$image_tarfile;
		print "cmd: ".$docker_save_cmd."\n";
		system($docker_save_cmd);
	}
	
	unless (defined $tag) {
		die;
	}
	
	#print "return $image_tarfile, $tag, $image_id, $docker_base_image\n";
	return [$image_tarfile, $image_id, $docker_base_image];
}


sub upload_docker_image_to_shock {
	
	
	my ($image_tarfile, $tag, $image_id, $docker_base_image) = @_;
	### upload image to SHOCK ###
	#check token
	#check server
	
	unless (defined $tag) {
		die;
	}
	
	
	require SHOCK::Client;
	
	
	if (!defined($ENV{'GLOBUSONLINE'}) ||  $ENV{'GLOBUSONLINE'} eq '') {
		die 'GLOBUSONLINE token not found';
	}
	
	unless (defined $shock) {
		$shock = new SHOCK::Client($shock_server, $ENV{'GLOBUSONLINE'});
	}
	
	
	system("rm -f Dockerfile");
	
	my $filename = 'Dockerfile';
	open(my $fh, '>', $filename) or die "Could not open file '$filename' $!";
	print $fh "My first report generated by perl\n";
	close $fh;
	print "done\n";
	
	
	
	my $shock_json =	'{'.
						' "temporary":"1",'.
						' "docker":"1",'.
						' "tag":"'.$tag.'",'.
						' "image_id":"'.$image_id.'",'.
						' "base_image_tag":"'.$docker_base_image.'"'.
						'}';
	
	print "upload image to SHOCK docker repository\n";
	my $up_result = $shock->upload('file' => $image_tarfile, 'attr' => $shock_json) || die;
	#same as: my $curl_cmd = 'curl -X POST -H "Authorization: OAuth $GLOBUSONLINE"  -F "attributes=@sodoku_docker.json" -F "upload=@'.$image_tarfile.'" "'.$shock_server.'/node"';
	print Dumper($up_result);
	unless ($up_result->{'status'} == 200) {
		die;
	}
	
	my $shock_node_id = $up_result->{'data'}->{'id'} || die "SHOCK node id not found for uploaded image";
	
	$shock->permisson_readable($shock_node_id) || die "error makeing node readable";
	
	print "Docker image uploaded.\n";
		
	return $shock_node_id;
	
}

sub upload_dockerfile_to_shock {
	my ($dockerfile, $tag, $docker_base_image) = @_;
	### upload image to SHOCK ###
	#check token
	#check server
	
	unless (defined $tag) {
		die;
	}
	
	
	require SHOCK::Client;
	
	
	if (!defined($ENV{'GLOBUSONLINE'}) ||  $ENV{'GLOBUSONLINE'} eq '') {
		die 'GLOBUSONLINE token not found';
	}
	
	unless (defined $shock) {
		$shock = new SHOCK::Client($shock_server, $ENV{'GLOBUSONLINE'});
	}
	
	my $shock_json =	'{'.
						' "temporary":"1",'.
						' "dockerfile":"1",'.
						' "tag":"'.$tag.'",'.
						' "base_image_tag":"'.$docker_base_image.'"'.
						'}';
	
	#print "tag: \"$tag\"\n";
	#print "docker_base_image: \"$docker_base_image\"\n";
	#print "shock_json: \"$shock_json\"\n";
	#exit(0);
	print "upload dockerfile to SHOCK docker repository\n";
	my $up_result = $shock->upload('data' => $dockerfile, 'attr' => $shock_json) || die;
	
	print Dumper($up_result);
	unless ($up_result->{'status'} == 200) {
		die;
	}
	
	my $shock_node_id = $up_result->{'data'}->{'id'} || die "SHOCK node id not found for uploaded dockerfile";
	
	$shock->permisson_readable($shock_node_id) || die "error makeing node readable";
	print "Dockerfile uploaded.\n";
	
	
	return $shock_node_id;
	
}

sub dockerSocket {
	my ($request_type, $endpoint) = @_;
	my $cmd = 'echo -e "'.$request_type.' '.$endpoint.' HTTP/1.0\r\n" | nc -U /var/run/docker.sock';
	$cmd = "bash -c '$cmd'";
	print "cmd: $cmd\n";
	my $return_value = `$cmd`;
	chomp($return_value);
	print "return_value: \"$return_value\"\n";
	
	my ($return_header, $return_body) = split(/\n\s*\n/, $return_value);
	chomp($return_header);
	
	print "return_header:\n\"$return_header\"\n";
	print "return_body:\n\"$return_body\"\n";
	my @return_body_lines = split("\n", $return_body);
	
	my $hash=undef;
	if (@return_body_lines > 0 && $return_body_lines[-1] =~ /\}/) {
		$hash = decode_json($return_body_lines[-1]);
	}

	my $body = undef;
	unless (defined $hash) {
		$body = $return_body;
	}

	unless (defined $hash || defined $body) {
		die;
	}

	return ($hash, $body);
}


sub addDockerCmd {
	my $docker_line = 'RUN '.join(' ', @_);
	
	if ((@docker_file_content > 0) && ($docker_file_content[-1] eq $docker_line)) {
		return;
	}
	
	
	my $cmd_lines = shift(@_);
	my @cmds = split(/\s*\&\&\s*|\s*\;\s*/,$cmd_lines);
	foreach my $cmd (@cmds) {
		my @cmd_array = split(/\s+/, $cmd);
		my $cmd = $cmd_array[0];
		print "command found: ".$cmd."\n";
		$docker_deps->{$cmd}=1;
	}
	push(@docker_file_content, $docker_line);

	
}

sub systemp {
	print "cmd: ".join(' ', @_)."\n";
	
	if ($d) {
		addDockerCmd(@_);
		
		return 0;
	}
	
	return system(@_);
}

sub modifyINIfile {
	my ($inifile, $ini_hash) = @_;
	
	print "read INI-file $inifile\n";
	
	eval "require Config::IniFiles; 1" # cpanm install Config::IniFiles
	or die "perl module required, e.g.: sudo apt-get install cpanminus ; sudo cpanm install Config::IniFiles";
	
	
	my $cfg = Config::IniFiles->new( -file => $inifile );
	
	foreach my $section (keys %$ini_hash) {
		my $section_hash = $ini_hash->{$section};
		foreach my $key (keys %$section_hash) {
			my $value = $section_hash->{$key};
			
			setINIvalue($cfg, $section, $key, $value);
			
		}
	}
	
	print "write INI-file $inifile\n";
	$cfg->WriteConfig($inifile);
	
}

sub setINIvalue {
	my ($cfg, $section, $key, $value) = @_;
	
	
	if ($cfg->exists($section, $key)) {
		$cfg->setval($section, $key, $value);
	} else {
		$cfg->newval($section, $key, $value);
	}
	
}

#example:[section]key=value?key=value...
sub INI_cmds_to_hash {
	
	my $strings = shift(@_);
	
	my $ini_hash={};
	foreach my $parameter (@{$strings}) {
		my ($section, $pair_string) = $parameter =~ /^\[(\S+)\](.*)$/;
		
		unless (defined($section) && defined($pair_string)) {
			die "could not parse config string: $parameter, required format: [section]key=value";
		}
		
		my @pairs = split('\?', $pair_string);
		if (@pairs == 0) {
			die;
		}
		
		foreach my $pair (@pairs) {
			my ($key, $value) = split('=', $pair);
			unless (defined $key && defined $value) {
				print $parameter." , ".$pair."\n";
				die;
			}
			$ini_hash->{$section}->{$key} = $value;
		}
		
	}
	
	
	return  $ini_hash;
}




sub downloadFile {
	my %args = @_;
	
	my $url = $args{'url'};
	my $dir = $args{'target-dir'};
	my $targetname = $args{'target-name'};
	#my $output = $args{'output'};

	unless (defined $dir) {
		die;
	}
	
	unless (defined $url) {
		die;
	}
	
	if (substr($dir, -1, 1) ne '/') {
		$dir .= '/';
	}
	
	
	my $file;
	unless (defined $targetname) {
		
		my $basefilename = (split qr{/}, $url)[-1];  # detect filename if possible
		
		unless (defined $basefilename) {
			die "filename could not be detected from url $url";
		}
		
		
		$targetname = $basefilename;
	}
	
	$file = $dir. $targetname;
	
	if (-e $file) {
		if ( (defined($h->{'new'}) ) || (definedAndTrue($args{'remove-existing-file'}) ) ) {
			systemp("rm -f $file");
		} else {
			print "skip file: $file already exists....\n";
			return $file;
		}
	}
	
	my $ssl= "";
	if (defined $h->{'nossl'}) {
		$ssl = "--insecure";
	}
	
	
	my $curl_download_cmd = "cd $dir && curl $ssl -L -o $targetname --retry 1 --retry-delay 5 \"$url\"";
	
	my $file_downloaded = 0;
	if ($shock_client_module_available && $d==0) { # TODO use this only for versioned downloads !!!!
		print "try using SHOCK cache\n";
		#check SHOCK
		
		unless (defined $shock) {
			$shock = new SHOCK::Client($shock_server, $ENV{'GLOBUSONLINE'});
		}
		my $download_return = $shock->cached_download($url, $dir, $targetname, $curl_download_cmd);
		
		if (defined $download_return) {
			$file_downloaded = 1;
			print "file downloaded from SHOCK cache\n";
		}
		
		
	}
	
	
	if ($file_downloaded == 0) {
		systemp($curl_download_cmd) == 0 or die;
	} else {
		# file was downloaded from SHOCK cache
		if ($d) {
			#Dockerfile still needs to download it
			addDockerCmd($curl_download_cmd);
		}
	}
	
	unless (-s $file || $d) {
		die "file $file was not downloaded!?";
	}
	
	#my $fh = File::Temp->new(DIR => $dir, TEMPLATE => 'temp_XXXXXXXXX');
	#my $fname = $fh->filename;
	
	return $file;
	
}

# process global variables
sub process_scalar {
	my $text = shift;
	
	$text =~ s/\$target/$target/g ;
	$text =~ s/\$\{target\}/$target/g ;
	
	$text =~ s/\$\{data_target\}/$data_target/g ;
	
	
	my @variables = ($text =~ m/\$\{(\S+)\}/g);
	
	foreach my $var (@variables) {
		if (defined $ENV{$var}) {
			my $value = $ENV{$var};
			$text =~ s/\$\{$var\}/$value/ ;
		}
	}
	
	
	
	return $text;
}

sub datastructure_walk {
    my %arghash = @_;
	my $datastructure = $arghash{'data'};
	my $sub = $arghash{'sub'}; # function sub will applied to all scalars
	my $arg = $arghash{'subarg'};
	
	my $user_specific = $arghash{'user_specific'} || 0;
	
	my $show=0;
	
	if (ref($datastructure) eq 'HASH') {
		
		
		if ($user_specific == 1 ) {
			### replace keyword names and delete subtrees
			my @keys = keys(%$datastructure);
			foreach my $key (@keys) {
				print "key: $key\n";
				my ($user, $keyword) = $key =~ /^(USER|ROOT)\_(.*)$/;
				if (defined $keyword) {
					
					print "user: $user\n";
					print "keyword: $keyword\n";
					
					if ( ($user eq 'USER' && $is_root_user==0) || ($user eq 'ROOT' && $is_root_user==1) ) {
						$datastructure->{$keyword} = delete $datastructure->{$key};
						print "replace $key with $keyword\n";
					} else {
						delete $datastructure->{$key};
						print "delete $key\n";
					}
				}
				
			}
		}
		
		while (my ($k, $v) = each %$datastructure) {
			if ($show==1) {print "goto $k\n";}
			if (ref($v) eq '') {
				#print "scalar: ".$datastructure->{$k}."\n";
				if (defined $sub) {
					$datastructure->{$k} = $sub->($v, $arg);
				}
				#print "scalar: ".$datastructure->{$k}."\n";
			} else {
				unless (defined($arghash{'nosubpackages'}) && $k eq "subpackages") {
					my %newhash = @_;
					$newhash{'data'} = $v;
					datastructure_walk(%newhash); #'data' => $v, 'sub' => $sub, 'subarg' => $arg
				} else  {
					if ($user_specific == 1 ) {
						my %newhash = @_;
						$newhash{'data'} = $v;
						
						
					}
				}
			}
		}
	} elsif (ref($datastructure) eq 'ARRAY') {
		for (my $i = 0 ; $i < @$datastructure ; $i++ ) {
			if (ref($datastructure->[$i]) eq '') {
				#print "scalar: ".$datastructure->[$i]."\n";
				if (defined $sub) {
					$datastructure->[$i] = $sub->($datastructure->[$i], $arg);
				}
				#print "scalar: ".$datastructure->[$i]."\n";
			} else {
				
				my %newhash = @_;
				$newhash{'data'} = $datastructure->[$i];
			
				datastructure_walk(%newhash); # 'data' => $datastructure->[$i], 'sub' => $sub, 'subarg' => $arg
			}
		}
	
	} elsif (ref($datastructure) ne '') {
		die "got: ".ref($datastructure);
	} else {
		# non-ref scalar !?
		print "scalar: $datastructure\n";
		die;
		
	}
	
	return;
}


sub setenv {
	my ($key, $value) = @_;
	
	if ($d) {
		push(@docker_file_content, "ENV $key $value");
		return;
	}
	
	
	my $envline = "export $key=$value";
	#systemp("grep -q -e '$envline' ~/.bashrc || echo '$envline' >> ~/.bashrc");
	
	bashrc_append($envline);
	
	if ($value =~ /\$/ || $value =~ /\~/) {
		#make sure that environment variables are evaluated
		my $echocmd = "echo \"$value\"";
		$value = `$echocmd`;
		chomp($value);
	}
	
	$ENV{$key}=$value; # makes sure variable can be used even if bashrc is not sourced yet.
	return;
}


sub bashrc_append {
	my $line = shift(@_);
	
	
	my $bashrc = '~/.bashrc';
	
	if ($is_root_user) {
		$bashrc = '/etc/profile';
	}
	
	my $cmd = "grep -q -e '$line' $bashrc || echo '$line' >> $bashrc";
	systemp($cmd);
}


sub git_clone {
	my ($source, $dir, $gitbranch) = @_;
	
	
	my $gitname;
	
	#example git://github.com/qiime/qiime-deploy.git
	#example kbase@git.kbase.us:dev_container
	$gitname = (split(/\/|:/, $source))[-1]; # split on "/" and ":"
	
	if ($gitname =~ /\.git$/) { # remove .git suffix
		($gitname) = $gitname =~ /(.*)\.git/;
	}
		
	unless (defined $gitname){
		die "git string unkown: $source";
	}
	
	my $usebranch="";
	if (defined $gitbranch) {
		#systemp("cd $gitdir && git checkout ".$gitbranch) == 0 or return undef;
		$usebranch = ' -b '.$gitbranch;
	}
	
	
	my $gitdir = $dir.$gitname.'/';
	print "gitdir: $gitdir\n";
	if (-d $gitdir) {
		if (defined $h->{'update'}) {
			systemp("cd $gitdir && git pull") == 0 or return undef;
			return $gitdir;
		}
		if (defined $h->{'new'}) {
			systemp("rm -rf $gitdir") == 0 or die;
		}
	}
	systemp("cd $dir && git clone --recursive $usebranch $source") == 0 or return undef;
	
	
	
	print "git_clone returns $gitdir\n";
	return $gitdir;
}

sub hg_clone {
	my ($source, $dir) = @_;
	
	my $hgname = (split('/', $source))[-1];
	
	unless (defined $hgname) {
		die;
	}
	
	my $hgdir = $dir.$hgname;
	
	if (-d $hgdir) {
		if (defined $h->{'update'}) {
			systemp("cd $hgdir && hg update") == 0 or die;
			return $hgdir;
		}
		if (defined $h->{'new'}) {
			systemp("rm -rf $hgdir") == 0 or die;
		}
	}
	
	systemp("cd $dir && hg clone ".$source) == 0 or die;
	
	return $hgdir;
}


# replaces ${i} variables
sub replaceArguments {
	my $exec = shift(@_);
	my $package_args_ref = shift(@_);
	
	unless (defined $package_args_ref) {
		$package_args_ref=[];
	}
	
	print "exec: $exec\n";
	print "package_args: ".@$package_args_ref."\n";
	
	
	for (my $i = 0 ; $i < @$package_args_ref; $i++) {
		my $k = $i+1;
		my $j = $package_args_ref->[$i];
		
		#print "j: ".$j."\n";
		$exec =~ s/\$\{$k\}/$j/g;
	}
	
	my $package_args_string = join(' ', @$package_args_ref);
	$exec =~ s/\$\{arguments\}/$package_args_string/g;
	
	
		
	
	print "exec: $exec\n";
	return $exec;
}

sub replaceVersionNumbers {
	my $exec = shift(@_);
	my $version_numbers_ref = shift(@_);
	
	unless (defined $version_numbers_ref) {
		return $exec;
	}
	
	print 'ref: '.ref($version_numbers_ref)."\n";
	
	print "exec: $exec\n";
	print "version_numbers: ".@$version_numbers_ref."\n";
	if (@$version_numbers_ref > 0) {
		for (my $i = 0 ; $i < @$version_numbers_ref; $i++) {
			my $k = $i+1;
			my $j = $version_numbers_ref->[$i];
			
			#print "j: ".$j."\n";
			$exec =~ s/\$\{v$k\}/$j/g;
		}
	} else {
		die;
	}
	print "exec: $exec\n";
	return $exec;
}

sub replacePtarget {
	my $exec = shift(@_);
	my $ptarget = shift(@_);
	
	unless (defined $ptarget) {
		die;
	}
	
	#print 'ref: '.ref($version_numbers_ref)."\n";
	
	#print "replacePtarget_A: $exec\n";
	$exec =~ s/\$\{ptarget\}/$ptarget/g;
	
	#print "replacePtarget_B: $exec\n";
	return $exec;
}


sub parsePackageString{
	my $package_string = shift(@_);
	
	#print "package_string: $package_string\n";
	
	my $package = undef;
	my ($p, $package_arg_line) = $package_string =~ /^(.*)(\(.*\))$/;
	
	my @package_args=();
	if (defined $package_arg_line) {
		$package = $p;
		($package_arg_line)= $package_arg_line =~ /^\((.*)\)$/;
		#print "package_arg_lineB: $package_arg_line\n";
		
		if (defined $package_arg_line && $package_arg_line ne "") {
			@package_args = split(' ', $package_arg_line) ;
		}

		
	} else {
		$package = $package_string;
	}
	
	#print "package_args_got: ".join(',', @package_args)."\n";
	
	
	my $argref = undef;
	if (@package_args > 0) {
		$argref = \@package_args;
	}

	
	my ($p2, $version) = $package =~ /^(.*)\=\=(.*)$/;
	
	if (defined $p2 && defined $version) {
		$package = $p2;
		
		my @version_array = split(/\./, $version); # make it an array_ref
		
		if (@version_array == 0) {
			die "version string parsing failed: \"$version\"";
		}
		
		$version = \@version_array;
		
	} else {
		$version = undef;
	}
	
	
	return ($package, $version, $argref);
	
}


my $functions = {};

# examples:
# https://github.com/wgerlach/amethst/playground
# amethst/playground
# amethst
sub function_kbasemodules {
	my %arghash = @_;
	
	#my $server = $arghash{'server'} or die;
	my $target = $arghash{'target'} or die;
	my $package_list = $arghash{'package-list'} || "";
	
	
	
	
	if (substr($target, -1, 1) ne "/") {
		$target .= '/';
	}
	
	my @kbase_modules = split(' ', $package_list);
	
	my $downloaded_modules = {};
	while (@kbase_modules > 0) {
		my $module = shift(@kbase_modules);
		my @server_list = ('https://anonymous:anonymous@github.com/kbase/', 'kbase@git.kbase.us:');
		
		my ($use_server, $mod) = $module =~ /^(http.?:\/\/github.com\/[a-zA-Z0-9\.\-\_]+\/)(.*)$/;
		
		if (defined $mod) {
			$module = $mod;
			print "use_server: $use_server\n";
			
			# set arbitary password to avoid username prompt
			my $search = 'github.com';
			my $replace = 'anonymous:anonymous@github.com';
			$use_server =~ s/$search/$replace/;
			
			@server_list = ($use_server);
		}
		
		my ($modx, $branch) = split('/', $module);
		
		if (defined $branch) {
			print "branch: $branch\n";
			$module = $modx;
		}
		
		
		unless (defined $downloaded_modules->{$module}) {
			
			
			print "kbase module requested: ".$module."\n";
			
			my $gitdir = undef;
			foreach my $this_server (@server_list) {
				$gitdir = git_clone($this_server.$module, $target, $branch);
				
				if (defined $gitdir) {
					last;
				}
			}
			
			unless (defined $gitdir) {
				die "Could not clone KBase module $module";
			}
			
			$downloaded_modules->{$module} = 1;
			
			my $filename = $gitdir.'DEPENDENCIES';
			if (-e $filename) {
				open my $fh, "<", $filename
				or die "could not open $filename: $!";
				my @deps = <$fh>;
				chomp(@deps);
				push(@kbase_modules, @deps);
			}
				
			
			
			
		}
		
	}
	
	
}

$functions->{'kbasemodules'} = \&function_kbasemodules;


sub definedAndTrue {
	my $x = shift(@_);
	if (defined $x && $x == 1) {
		return 1;
	}
	return 0;
}

sub get_array {
	my $ref = shift(@_);
	my @array;
	
	if (ref($ref) eq 'ARRAY' ) {
		@array = @{$ref};
	} else {
		@array = ($ref);
	}
	
	return @array;
}


sub array_execute {
	my ($argument, %replacements) = @_;
	
	
	my @execs;
	if (ref($argument) eq 'ARRAY') {
		@execs = @{$argument};
	} else {
		@execs = ($argument);
	}
	foreach my $exec (@execs) {
		
		foreach my $key (keys(%replacements)) {
			my $value = $replacements{$key};
			if (defined $value) {
				$exec =~ s/\$\{$key\}/$value/g;
			}
		}
		
		print "exec:\n";
		systemp($exec) == 0 or die;
	}
	
}

sub chdirp {
	my $ptarget = shift(@_);
	if ($d) {
		print 'cmd: cd '.$ptarget."\n";
	} else {
		chdir($ptarget);
	}
}

sub install_package {
	my ($repository, $package_hash, $package, $version, $package_args_ref) = @_;
	
	#print 'ref1: '.ref($version)."\n";
	#print "$package: ". Dumper($package_hash);
	
	
	
	if (definedAndTrue($package_hash->{'ignore'})) {
		print STDERR "package $package ignored.\n";
		return;
	}
	
	if (defined $package_hash->{'ignore'}) {
		die;
	}
	
	
	# replace arguments if they have been used
	datastructure_walk('data' => $package_hash, 'sub' => \&replaceArguments, 'subarg' => $package_args_ref);
	
	
	print "install package: $package\n";
	print "args: ".join(' ',@$package_args_ref)."\n" if defined $package_args_ref;
	
	
	unless (defined $package_hash) {
		print STDERR "error: no configuration found for package $package\n";
		exit(1);
	}
	
	# START installation ########################
	#if (defined $already_installed{$package} && $already_installed{$package}==1) {
	if (definedAndTrue($already_installed{$package})) {
		print "package $package already installed, skip it...\n";
		next;
	}
	
	if (defined $version) {
		#print 'ref2: '.ref($package_hash->{'version'})."\n";
		$package_hash->{'version'} = $version;
	}
	if ((defined $package_hash->{'version'}) && ($package ne "subpackage")) {
		#print 'ref3: '.ref($package_hash->{'version'})."\n";
		datastructure_walk('data' => $package_hash, 'sub' => \&replaceVersionNumbers, 'subarg' => $package_hash->{'version'});
	}
	
	my $ptarget = $package_hash->{'ptarget'} || $target;
	
	# package is a data package ?
	if ( defined($h->{'data_target'}) && definedAndTrue($package_hash->{'data'}) ) {
		unless ( defined($package_hash->{'ptarget'}) ) {
			$ptarget = $h->{'data_target'};
			print "ptarget not defined: use data_target\n";
		} else {
			print "ptarget defined: $ptarget\n";
		}
		print "is data package\n";
	} else {
		print "is normal software package\n";
	}
	
	if (substr($ptarget, -1, 1) ne '/') {
		$ptarget .= '/';
	}
	
	#if (defined($package_hash->{'ptarget'})) {
	datastructure_walk('data' => $package_hash, 'sub' => \&replacePtarget, 'subarg' => $ptarget, 'nosubpackages' => 1);
	#}
	
	if (definedAndTrue($package_hash->{'dir'}) && defined($package_hash->{'ptarget'})) {
		die;
	}
	if (definedAndTrue($package_hash->{'dir'})) {
		$ptarget .= $package.'/';
		$package_hash->{'ptarget'} = $ptarget;
	}
	

	unless (-d $ptarget) {
		systemp("mkdir -p ".$ptarget);
	}

	
	#dependencies
	if (defined $package_hash->{'depends'} && ! defined($h->{'nodeps'})) {
		foreach my $dependency (@{$package_hash->{'depends'}}) {
			
			my ($dep_package, $dep_version, $dep_package_args_ref) = parsePackageString($dependency);
			
			if ( definedAndTrue( $already_installed{$package} ) ) {
				print "dependency $dependency already installed\n";
			}else {
				print "install dependency $dependency for $dep_package...\n";
				unless (defined $repository->{$dep_package}) {
					die "package $dep_package not found\n";
				}
				install_package($repository, $repository->{$dep_package}, $dep_package, $dep_version, $dep_package_args_ref);
			}
		}
	}
	
	
		
	chdirp($ptarget);

	
	
	#subpackages
	if (defined $package_hash->{'subpackages'}) {
		my $subpackages =$package_hash->{'subpackages'};
		foreach my $subpackage (@{$subpackages}) {
			if (defined($package_hash->{'ptarget'}) && ! defined($subpackage->{'ptarget'})) { # inherit ptarget
				$subpackage->{'ptarget'} = $package_hash->{'ptarget'};
			}
			print "install subpackage for $package...\n";
			install_package($repository, $subpackage, "subpackage", $version, $package_args_ref); #recursive !
		}
	}
	
	
	chdirp($ptarget);
	
	if ($package_hash->{'depend-function'}) {
		
		foreach my $function_hash (@{$package_hash->{'depend-function'}}) {
			my $function_name = $function_hash->{'name'};
			&{$functions->{$function_name}}(%$function_hash);
		}
		
		
	}
	
	
	if (defined $package_hash->{'source-as-parameter'} && $package_hash->{'source-as-parameter'} ==1) {
		if (defined $package_args_ref) {
			push(@{$package_hash->{'source'}}, @{$package_args_ref});
			print "source total: ".join(',', @{$package_hash->{'source'}})."\n";
		}
	}

	if (defined $package_hash->{'set-env'}) {
		my $env_pairs = $package_hash->{'set-env'};
		foreach my $key (keys %{$env_pairs} ) {
			setenv($key, $env_pairs->{$key}) ;
		}
	}
	
	# resolve short-hand notation
	foreach my $type ('apt', 'pip', 'git', 'go', 'mercurial') {
		if (defined $package_hash->{'source-'.$type}) {
			$package_hash->{'source'} = $package_hash->{'source-'.$type};
			$package_hash->{'source-type'} = $type;
		}
	}
	
	if (defined $package_hash->{'source'}) {
		my @sources = get_array($package_hash->{'source'});
		
		my $build_type = $package_hash->{'build-type'} || 'exec';
		
		my $source_type = $package_hash->{'source-type'} || 'auto';
		
		my $temp_dir_obj = undef;
		my $temp_dir = $ptarget;
		
		if (definedAndTrue($package_hash->{'source-temporary'})) {
			
			if ($d) {
				$temp_dir = '/tmp/sodoku_deploy/';
				systemp('rm -rf '.$temp_dir);
				systemp('mkdir -p '.$temp_dir);
			} else {
				$temp_dir_obj = File::Temp->newdir( TEMPLATE => 'deployXXXXX' );
				$temp_dir = $temp_dir_obj->dirname.'/';
			}
		}
		
		my $source_dir=$ptarget;
		my $source_subdir;
		my $downloaded_file=undef;
		
		foreach my $source_obj (@sources) {
			
			my $source;
			my $source_filename;
			
			my $source_branch;
			if (ref($source_obj) eq 'HASH') {
				$source = $source_obj->{'url'};
				$source_subdir = $source_obj->{'subdir'};
				$source_filename=$source_obj->{'filename'};
				$source_branch=$source_obj->{'branch'};
			} else {
				$source = $source_obj;
			}
			
			
			# detect source type
			my $st = $source_type;
			if ($st eq 'auto') {
				#autodetect source type
				if ($source =~ /^git:\/\//) {
					$st = 'git';
				} elsif (defined($package_hash->{'git-server'})) {
					$st = 'git';
				} elsif ($source =~ /\@git\./) {
					$st = 'git';
				} elsif ($source =~ /^ssh.*\.git/) {
					$st = 'git';
				} else {
					$st='download';
				}
				
			}
			
			
			
			$source_dir=$ptarget;
			
			if ($st eq 'git' && defined($package_hash->{'git-server'})) {
				$source = $package_hash->{'git-server'}.$source;
			}
			
			
			
			if ($st eq 'git' || $st eq 'mercurial' || $st eq 'go') {
				if (@sources > 1 ) {
					die "only one $st-source per package possible";
				}
				
				
				if ($st eq 'git') {
					$source_dir = git_clone($source, $temp_dir, $source_branch) || die;
				} elsif ($st eq 'mercurial') {
					$source_dir = hg_clone($source, $temp_dir);
				} elsif ($st eq 'go') {
					#-fix -u  github.com/MG-RAST/AWE/...
					
					my $update_works = 0;
					if (defined $h->{'update'}) {
						if (systemp("go get -fix -u ".$source) == 0){
							$update_works = 1;
						}
					}
					
					# try to delete previous repository
					if (defined $h->{'new'}) {
					#rm -rf gopath/src/github.com/
						unless (defined $ENV{'GOPATH'}) {
							die "GOPATH environment variable not found";
						}

						if ($ENV{'GOPATH'} eq '') {
							die "GOPATH environment variable empty";
						}

						
						if (-d $ENV{'GOPATH'} ) {
							my $src_dir = $ENV{GOPATH}.'/src/'.$source;
							print "src_dir: $src_dir\n";
							while (substr($src_dir, -1, 1) eq '.') {
								chop($src_dir);
							}
							while (substr($src_dir, -1, 1) eq '/') {
								chop($src_dir);
							}
							if (-d $src_dir) {
								systemp("rm -rf ".$src_dir);
								sleep(1);
							}
						} else {
							systemp("mkdir -p ".$ENV{'GOPATH'});
						}
						
					}
					
					if ($update_works == 0) {
						systemp("cd ".$ENV{'GOPATH'}." && go get ".$source) == 0 or die;
					}
				} else {
					die "repository type unknown";
				}
			
			} elsif ($st eq 'pip') {
				my $pip_options = "";
				#unless (defined($h->{'root'})) {
				#	$pip_options = " --user ".$ENV{'USER'}; # does not work!
				#}
				my $pip_cmd = "pip install ".$source.$pip_options;
				unless ($is_root_user) {
					$pip_cmd = "sudo ".$pip_cmd;
				}
				systemp($pip_cmd) == 0 or die;
			} elsif ($st eq 'apt') {
				my $apt_cmd =  "apt-get --force-yes -y install ".$source;
				unless ($is_root_user) {
					$apt_cmd = "sudo ".$apt_cmd;
				}
				systemp($apt_cmd) == 0 or die;
			} elsif ($st eq 'download') {
				#simple download
				
				$downloaded_file = downloadFile('url' => $source,
												'target-dir' => $temp_dir, #$ptarget,
												'target-name' => $source_filename,
												'remove-existing-file' => $package_hash->{'source-remove-existing-file'});
				unless (defined $downloaded_file) {
					die;
				}
				
				if (definedAndTrue($package_hash->{'source-extract'})) {
					if ($downloaded_file =~ /\.tar\.gz$/) {
						systemp("tar xvfz ".$downloaded_file." -C ".$temp_dir) ==0 or die;
					} elsif ($downloaded_file =~ /\.tgz$/) {
						systemp("tar xvfz ".$downloaded_file." -C ".$temp_dir) ==0 or die;
					} elsif ($downloaded_file =~ /\.zip$/) {
						systemp("unzip ".$downloaded_file." -d ".$temp_dir) ==0 or die;
					} elsif ($downloaded_file =~ /\.tar\.bz2$/) {
						
						my ($tarfile) = $downloaded_file =~ /^(.*)\.bz2$/;
						defined($tarfile) or die;
						systemp("rm -f ".$tarfile);
						systemp("bzip2 -d ".$downloaded_file) ==0 or die;
						
						unless (-e $tarfile || $d) {
							die "tarfile \"$tarfile\" not found";
						}
						
						systemp("tar xvf ".$tarfile." -C ".$temp_dir) ==0 or die;
						
						
					} elsif ($downloaded_file =~ /\.gz$/) {
						my ($uncompressed) = $downloaded_file =~ /^(.*)\.gz$/;
						if (defined $h->{'new'}) {
							systemp("rm -f ".$temp_dir.$uncompressed);
						}
						
						systemp("gzip -d ".$downloaded_file) ==0 or die;
						
						
						
					} else {
						die "unknown archive: $downloaded_file";
					}
					$source_dir=$temp_dir;
				}
				
			} else {
				die "source_type \"$st\" unknown";
			
			}
			
		} # end @sources
	
		
		my $build_dir = $source_dir;
		
		if (defined $source_subdir) {
			
			if (@sources > 1 ) {
				die "source_subdir: not sure that this makes sense";
			}
			
			$build_dir .= $source_subdir;
		}

		if (substr($build_dir,-1,1) ne '/') {
			$build_dir .= '/';
		}
		
		chdirp($build_dir);
		
		### BUILD INSTRUCTIONS ###
		
		# different build-types
		if (defined($package_hash->{'build-exec'})) {
			
			print "sourcedir: $source_dir\n";
			
			if (@sources > 1 ) {
				array_execute($package_hash->{'build-exec'});
			} else {
				array_execute($package_hash->{'build-exec'}, 'source-file' => $downloaded_file, 'source-dir' => $source_dir);
			}
		} elsif ($build_type eq 'make-install' || $build_type eq 'make'){
			
			if (@sources > 1 ) {
				die "make/make-install: not sure that this makes sense";
			}
			
			# change directory if needed
			#if (! -e $build_dir.'configure' && -e $build_dir.'Makefile' ) {
			#	opendir my $dir, "/some/path" or die "Cannot open directory: $!";
			#	my @files = readdir $dir;
			#	closedir $dir;
			#	print join(',', @files)."\n";
			#	die;
			#
			#}
			
			
			
			
			if (-e $build_dir.'configure') {
				systemp("cd $build_dir && ./configure --prefix=$ptarget") == 0 or die;
			}
			
			if (-e $build_dir.'Makefile' || $d) {
				systemp("cd $build_dir && make")== 0 or die; #TODO make -j4
			} else {
				die "Makefile in $build_dir not found";
			}
			if ($build_type eq 'make-install') {
				if (-e $build_dir.'Makefile'  || $d) {
					systemp("cd $build_dir && make install")== 0 or die; #TODO make -j4
				} else {
					die "Makefile in $build_dir not found";
				}
			}
			
		} else {
			# no build
		}
		
		
		### INSTALL INSTRUCTIONS ###

		foreach my $inst_type ('copy', 'binary') {
			if (defined($package_hash->{'install-'.$inst_type})) {
				print "install-type: ".$inst_type."\n";
				my @install_files_array = get_array($package_hash->{'install-'.$inst_type});
				
				my $install_target = $ptarget;
				
				if ($inst_type eq 'binary') {
					if ($is_root_user || $d) {
						$install_target = '/usr/local/bin/';
					} else {
						$install_target = $ENV{"HOME"}.'/bin/';
					}
					systemp('mkdir -p '.$install_target);
					
				}
				
				unless (defined $build_dir) {
					die;
				}
							
				foreach my $install_file (@install_files_array) {
					
					systemp('cp -f '.$build_dir.$install_file.' '.$install_target) == 0 or die;
					
					if ($inst_type eq 'binary') {
						systemp('chmod +x '.$install_target.$install_file) == 0 or die;
					}
					
				}
	
			}
		}
		
		
		
		
		
		if (definedAndTrue($package_hash->{'source-temporary'})  && $d) {
			systemp('rm -rf '.$temp_dir)
		}
		
		chdirp($ptarget);
		#temp_dir goes out of scope here

	}


	
	
	
	if (defined($package_hash->{'set-ini-values'})) {
		
		print "set-ini-values\n";
		
		my $inifile = $package_hash->{'set-ini-values'}->{'file'};
		unless (defined $inifile) {
			die "INI-file $inifile not defined";
		}
		
		unless (-e $inifile || $d) {
			die "INI-file $inifile not found";
		}
		
		
		my $cfg_string = $package_hash->{'set-ini-values'}->{'cfg-string'} || "";
		
		if ($cfg_string ne "") {
			
			print "cfg_string: \"$cfg_string\"\n";
			
			my @cfg_strings = split(' ', $cfg_string);
			
			my $ini_hash = INI_cmds_to_hash( \@cfg_strings );
			modifyINIfile($inifile, $ini_hash)
		}else {
			print STDERR "warning: cfg_string emtpy, will not modify $inifile\n";
		};
		
	}
	
	if (defined $package_hash->{'bashrc-append'}) {
		my @lines;
		if (ref($package_hash->{'bashrc-append'}) eq 'ARRAY') {
			@lines = @{$package_hash->{'bashrc-append'}};
		} else {
			@lines = ($package_hash->{'bashrc-append'});
		}
		foreach my $line (@lines) {
			bashrc_append($line) ;
		}
		
	}
	
	
	if (defined $package_hash->{'exec'}) {
		array_execute($package_hash->{'exec'});
	}
	
	if (defined $package_hash->{'test'}) {
		print "test_exec:\n";
		systemp($package_hash->{'test'}) == 0 or die;
	}
	

	unless ($package eq "subpackage") {
		$already_installed{$package} = 1;
	}
	
	#if (defined $package_hash->{'finish-package'}) {
	#	if (ref($package_hash->{'finish-package'}) eq 'ARRAY' ) {
	#		return $package_hash->{'finish-package'};
	#	} else {
	#		return ($package_hash->{'finish-package'});
	#	}
	#}
	

	if (defined $package_hash->{'version'}) {
		return $package_hash->{'version'};
	}
	
	return undef;
}

#############################################################

print "deploy arguments: ".join(' ', @ARGV)."\n";

GetOptions ($h, 'target=s', 'data_target=s', 'version=s', 'update', 'new', 'root', 'all', 'repo_file=s', 'repo_url=s', 'ignore=s', 'docker', 'dockerfile', 'dockerimage','docker_show_only', 'docker_reuse_image', 'docker_noupload', 'nossl', 'forcetarget', 'list', 'create', 'nodeps');

if ( @ARGV == 0 && ! defined $h->{'list'}) {
	print "usage: deploy_software.pl [--target=] [packages]\n";
	#print "default target=$target\n";
	print "example: deploy_software.pl --target=/home/ubuntu/ aweclient\n";
	print "     --data_target different target for packages marked with data=1\n";
	print "     --update to update existing packages if possible \n";
	print "     --new to delete packages before cloning \n";
	print "     --all to install all packages in repository \n";
	print "     --ignore=package1,package2\n";
	print "     --list\n";
	print "     --repo_file\n";
	print "     --repo_url\n";
	print "     --create  write repository.json by merging multiple json files\n";
	print "     --nodeps do not install dependencies\n";
	print "     \n";
	print "     --docker create and upload Dockerfile and Dockerimage\n";
	print "     --dockerfile create and upload Dockerfile\n";
	print "     --dockerimage create and upload Dockerimage\n";
	exit 1;
}



#my $error   = '';
#my $package = 'SHOCK::Client';
#{
#	no strict;
#	eval "require $package;";
#	$error = $@;
#}
#if ($error) {
#	$shock_client_module_available = 0;
#} else {
#	#my $resource_obj = $package->new($params);
#	$shock_client_module_available = 1;
#}






if (defined($h->{'docker'}) || defined($h->{'dockerfile'}) || defined($h->{'dockerimage'})) {
	$d = 1;
}

if (defined($h->{'docker'}) {
	$h->{'dockerfile'} = 1;
	$h->{'dockerimage'} = 1;
}


if ($d == 1) {
	
	
	
	eval {
		require SHOCK::Client;
		SHOCK::Client->import();
		$shock_client_module_available = 1;
		print "using SHOCK::Client\n";
		1;
	} or do {
		my $error = $@;
		print "not using SHOCK::Client : $error\n";
	};

	if ($shock_client_module_available == 0) {
		die "error: docker image upload to SHOCK requires module SHOCK::Client";
	}
}


if (defined $h->{'create'}) {
	
	my $repo_file = 'repository.json';
	
	if (-e $repo_file) {
		die "Repository file $repo_file already exists. Please delete old first.";
	}
	
	
	my $repository_merge={};
	
	my @error_file=();
	foreach my $file (@ARGV) {

		unless (-e $file) {
			die "file \"$file\" not found";
		}
		my $cat_cmd = "cat ".$file;
		my $repository_json = `$cat_cmd`;
		chomp($repository_json);
		my $repository;
		
		#try {
			$repository = decode_json($repository_json);
		#}
		#catch {
			#warn "caught error: $_"; # not $@
			#print Dumper($repository);
		#	print STDERR "warning: could not parse json in $file\n";
		#	push(@error_file, $file);
			#next;
		#};
		
		foreach my $key (keys(%$repository)) {
			if (defined $repository_merge->{$key}) {
				die "key $key already defined";
			}
			$repository_merge->{$key} = $repository->{$key};
			
		}
	}
	#print Dumper($repository_merge);
	
	my $json = JSON->new;
	my $repository_merge_pretty = $json->pretty->encode( $repository_merge );
	print $repository_merge_pretty ."\n";
	
	open(my $fh, '>', $repo_file);
	print $fh $repository_merge_pretty."\n";
	close $fh;
	
	
	if (@error_file > 0) {
		print "warning: problems with following files:".join(',',@error_file)."\n"
	}
	
	exit(0);
}




if (defined $h->{'update'} && defined $h->{'new'} ) {
	die;
}



if ($d) {
	$is_root_user = 1;
} else {
	$is_root_user = ($< == 0)?1:0;
	
	if ( ! defined($h->{'root'}) && $is_root_user ) {
		print "error: please do not run me as root unless you know what you are doing.\n";
		exit(0);
	}

	if (defined($h->{'root'}) &&  ! $is_root_user) {
		print "error: you gave option --root but you are not root.\n";
		exit(0);
	}

}
#my $target = "/kb/runtime/";

# in case we use cached installation
#maybe add to .bashrc : source /home/ubuntu/data/qiime_software/activate.sh

#cd data && wget ftp://ftp.metagenomics.anl.gov/data/misc/private/wolfgang_epaghsmh/qiime_software.tar.gz


if (defined $ENV{'TARGET'} ) {
	$target = $ENV{'TARGET'};
}

if (defined $h->{'target'}) {
	$target = $h->{'target'};
}




unless (defined $target) {
	$target = getcwd();
}

if (substr($target, -1, 1) ne "/") {
	$target .= "/";
}

if (defined($h->{'forcetarget'}) && ! -d $target) {
	systemp("mkdir -p ".$target);
}

if (defined $target) {
	unless (-d $target  || $d) {
		die "target \"$target\" not found!\n";
	}
} else {
	die;
}

if (defined $h->{'data_target'}) {
	$data_target = $h->{'data_target'};
	if (substr($data_target, -1, 1) ne "/") {
		$data_target .= "/";
	}
} else {
	$data_target = $target;
}



my $repository_json = <<'EOF';
{
	xxxxx
}
EOF

#my $package_rules = decode_json($package_rules_json);
my $repository = undef;


my $use_repository;

if (defined $h->{'repo_file'}) {
	$use_repository = $h->{'repo_file'};
	my $cat_cmd = "cat ".$use_repository;
	$repository_json = `$cat_cmd`;
	chomp($repository_json);
} else {
	if (defined $h->{'repo_url'}) {
		$use_repository = $h->{'repo_url'};
	} else {
		$use_repository = $default_repository;
	}
	
	print "fetching repository: ".$use_repository."\n";
	my $curl_cmd = "curl -S -s -o /dev/stdout ".$use_repository;
	$repository_json = `$curl_cmd`;
	chomp($repository_json);

}



print $repository_json."\n";

eval {
	$repository = decode_json($repository_json);
	1;
};
if ($@) {
	my $e = $@;
	print "$e\n";
	exit(1);
}

datastructure_walk('data' => $repository, 'sub' => \&process_scalar, 'user_specific' => 1); # for my "environment variables"... ;-)



my @package_list = @ARGV;

print "target: $target\n";


if (defined($h->{'ignore'})) {
	my @ignorepackages = split(',', $h->{'ignore'});
	foreach my $p (@ignorepackages) {
		if (defined($repository->{$p})) {
			$repository->{$p}->{'ignore'} = 1;
			print "ignore package $p requested\n";
		} else {
			die "package $p not found";
		}
	}
}


if (defined($h->{'list'})) {
	print "list of packages in repository:\n".join(',', keys(%$repository))."\n";
	exit(0);
}


my @packages_installed=();
foreach my $package_string (@package_list) {
	
	my ($package, $version, $package_args_ref) = parsePackageString($package_string);
	
	my $pack_hash = $repository->{$package};
	unless (defined $pack_hash) {
		#print "repository:\n";
		foreach my $p (keys(%$repository)) {
			print "$p\n";
		}
		print "\n";
		
		die "package $package not found\n";
	}
	
	my $used_version = install_package($repository, $pack_hash, $package, $version, $package_args_ref);
	push(@packages_installed,[$package, $used_version] );
}


if ($d) {
	
	if (@packages_installed > 1) {
		die "not supported";
	}
	
	my ($package, $version) = @{shift(@packages_installed)};
	
	
	# create Dockerfile
	my ($tag, $dockerfile) = @{createDockerFile($package, $version)};
	unless (defined $tag) {
		die;
	}
	
	# upload Dockerfile
	if (defined($h->{'dockerfile'})) {
		unless (defined $h->{'docker_noupload'}) {
			my $shock_node_id = upload_dockerfile_to_shock($dockerfile, $tag, $docker_base_image) || die;
		}
	}
	
	if (defined($h->{'dockerimage'})) {
		# create docker image
		my $ref = createDockerImage($tag, $dockerfile);
		my ($image_tarfile, $image_id, $docker_base_image) = @{$ref};
		
		
		# upload docker image
		unless (defined $h->{'docker_noupload'}) {
			my $shock_node_id = upload_docker_image_to_shock($image_tarfile, $tag, $image_id, $docker_base_image) || die;
		}
	}
}


unless ($d) {
	print "all packages installed.\n";
}









