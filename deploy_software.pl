#!/usr/bin/env perl

use strict;
use warnings;

use Cwd 'abs_path'; #'abs_path getcwd'
#use Getopt::Long;
use File::Basename;

eval "use JSON; 1"
or die "perl module required, e.g.: sudo apt-get install cpanminus ; sudo cpanm install JSON";

eval "use USAGEPOD; 1"
or die "USAGEPOD is missing:\n sudo apt-get install cpanminus \n sudo cpanm git://github.com/wgerlach/USAGEPOD.git";


use File::Temp;
use LWP::UserAgent;
use Data::Dumper;
#eval "use Try::Tiny; 1"
#or die "perl module required, e.g.: sudo apt-get install cpanminus ; sudo cpanm install Try::Tiny";

1;



my $default_repository = 'https://raw.github.com/wgerlach/SODOKU/master/merged-json/repository.json';

my $ubuntu_cmd2package = {
	'curl' => 'curl',
	'make' => 'make build-essential',
	'git' => 'git',
	'unzip' => 'unzip',
	'add-apt-repository' => 'software-properties-common'
};

my $docker_socket = '/var/run/docker.sock';

my $author = 'Wolfgang Gerlach';

my $shock_server = 'http://shock.metagenomics.anl.gov:80';

# for temporary files
my $datadir='/mnt/tmp/';
#my $tartemp = $datadir.'tar_temp/';

#########################################

my $target = undef;
my $data_target = undef;

my %already_installed;
my $h = {};

my $shock=undef;
my $docker_version_info = undef;
my $shock_client_module_available = 0;

my $d=undef; # docker inidicator

my @docker_file_content=();
my $docker_build_context_dir=undef;

my $docker_deps={};

my $is_root_user = undef;
my $shocktoken=undef;




sub createDockerFile {
	my ($docker_base_image) = @_;
	
	
	unless (defined $docker_base_image) {
		die "error: base image not defined";
	}
	
	
		
	print "deps: ".join(',', keys(%$docker_deps)) ."\n";
	
	my $dep_packages={};
	foreach my $dep (keys(%$docker_deps)) {
		my $pack = $ubuntu_cmd2package->{$dep};
		if (defined $pack) {
			$dep_packages->{$pack}=1;
		}
	}
	
	my @docker_file_header=(
		'# This file was auto generated by SODOKU (github.com/wgerlach/SODOKU/)',
		'FROM '.$docker_base_image,
		'MAINTAINER '.$author,
		'RUN apt-get update'
		);
	
	my $dockerfile='';
	
	$dockerfile .= join("\n", @docker_file_header)."\n";
	if (keys(%$dep_packages) > 0) {
		$dockerfile .= "RUN apt-get install -y ".join(' ', keys(%$dep_packages)) ."\n";
	}
	$dockerfile .= join("\n", @docker_file_content)."\n";
	
	print "------\nDockerfile\n";
	print $dockerfile;
	#exit(0);
	#my $tag = 'wgerlach/'.$package.':'.$version_str;
	
	#print "tag: \"$tag\"\n";
	
	return $dockerfile;
}


sub createDockerImage {
	
	my ($repo, $tag, $dockerfile, $docker_base_image) = @_;

	
	unless (defined $docker_base_image->{'id'}) {
		die; # TODO remove
	}
	
	my $repotag = $repo.':'.$tag;
	
	
	# check if image already exists
	
	my $result_hash = dockerSocket('GET', "/images/$repotag/json");
	
	my $image_id = undef;
	if (defined $result_hash) {
		$image_id = $result_hash->{'id'};
		unless (defined $image_id) {
			die "hash defined, but not id!?";
		}
		
		print Dumper($result_hash);
		print "image already exists:\n";
		print "ID: ".$image_id." $repotag\n";
		
		unless (defined $h->{'docker_reuse_image'}) {
			print "to delete it run docker rmi ".$image_id."\n";
			exit(1);
		}
		
		
	}

	
	
		
	
	
	#my $cwd = getcwd;
	
	
	unless (-d $datadir) {
		die "data dir not found";
	}
	
		
	
	### create docker image ###
	
	
	unless (defined($image_id) ) {
		
		
		#my $docker_build_cmd = 'docker build --tag='.$repotag.' -'; #--no-cache=true --rm
		my $docker_build_cmd;
		
		
		if (defined $docker_build_context_dir) {
			# use context dir
			
			write_file($docker_build_context_dir.'/Dockerfile', $dockerfile);
			
			$docker_build_cmd = 'docker build --tag='.$repotag.' '.$docker_build_context_dir;
			systemp($docker_build_cmd)==0 or die "docker build failed";
			
		} else {
			# no context, pipe dockerfile into docker client
			$docker_build_cmd = 'docker build --tag='.$repotag.' -'; #--no-cache=true --rm
			
			print "docker_build_cmd: $docker_build_cmd\n";
			
			open(my $fh, "|-", $docker_build_cmd)
			or die "cannot run docker: $!";
			
			print $fh $dockerfile;
			close ($fh);
			
			sleep(3);
		}
		
		
		
		
		
		
		if (0) {
			my $docker_build_cmd = 'docker build --tag='.$repotag.' -'; #--no-cache=true --rm
			
			print "docker_build_cmd: $docker_build_cmd\n";
			
			open(my $fh, "|-", $docker_build_cmd)
				or die "cannot run docker: $!";
		
			print $fh $dockerfile;
			close ($fh);
			
			sleep(3);
		}
		
		$result_hash = undef;
		
		$result_hash = dockerSocket('GET', "/images/$repotag/json");
		
		
		if (defined $result_hash) {
			$image_id = $result_hash->{'id'};
						
		} else {
			die "result_hash not defined, docker image was not created !?";
		}
		
	}
	
	unless (defined $image_id) {
		die "image ID not found";
	}

	### save image as tar archive file
	
	my $tag_converted = $repotag;
	$tag_converted =~ s/[\/]/\_/g;
	my $docker_base_image_converted = $docker_base_image->{'name'};
	$docker_base_image_converted =~ s/[\/]/\_/g;
	
	
	
	my $image_tarfile = $datadir.$image_id.'_'.$docker_base_image_converted.'_'.$tag_converted.'.complete.tar';
	#my $imagediff_tarfile = $datadir.$image_id.'_'.$docker_base_image_converted.'_'.$tag_converted.'.diff.tar';
	
	
	save_image_to_tar($image_id, $image_tarfile);
	
	unless (defined $repotag) {
		die;
	}
	
	# open and modify tar archive
	
	
	my $imagediff_tarfile_gz = remove_base_from_image_and_set_tag($image_tarfile, $repo, $tag, $image_id, $docker_base_image);
		
	
		
	#my $imagediff_tarfile_gz = $imagediff_tarfile.'.gz';
	unless (-e $imagediff_tarfile_gz) {
		die;
	}
	
	systemp("rm -f ".$image_tarfile);
	
	return [$imagediff_tarfile_gz, $image_id];
}

sub save_image_to_tar {
	my ($image_id, $image_tarfile) = @_;
	
	
	my $skip_saving = 0;
	
	
	if (defined $h->{'docker_reuse_image'}) {
		if (-e $image_tarfile) {
			$skip_saving = 1;
		}
	} else {
		if (-e $image_tarfile) {
			die "docker image file $image_tarfile already exists";
		}
	}
	
	
	if ($skip_saving == 0) {
		my $docker_save_cmd = 'docker save '.$image_id.' > '.$image_tarfile; # TODO: use API
		systemp($docker_save_cmd) == 0 or die;
	}
	
}

sub remove_base_from_image_and_set_tag {
	
	
	my ($image_tarfile, $repo, $tag, $image_id, $docker_base_image) = @_;
	
	unless ($image_tarfile =~ /\.tar$/) {
		die "tar expected";
	}
	
	my ($output_tar) = $image_tarfile =~ /^(.*)\.tar$/;
	
	unless (defined $output_tar) {
		die;
	}
	
	$output_tar .= '.diff.tar';
	
	my $output_targz  = $output_tar.'.gz';
	
	if (-e $output_targz) {
		die "error: \"".$output_targz."\" already exists";
	}
	
		
	my $tartemp = File::Temp->newdir( TEMPLATE => 'SODOKU_tar_XXXXXXX' );
	
	#systemp("mkdir -p $tartemp ; rm -f ".$output_tar);
	
	
	systemp("cd $tartemp && tar xvf ".$image_tarfile) ==0 or die;
	
	
	
	unless (defined $docker_base_image->{'id'}) {
		die; # TODO remove
	}
	
	my @diff_layers = get_diff_layers($image_id, $docker_base_image->{'id'});
	
	if (@diff_layers == 0) {
		die ;
	}
	
	my $diff_layers_hash = {};
	foreach my $layer (@diff_layers) {
		
		my $layer_dir = $tartemp.'/'.$layer;
		
		unless (-d $layer_dir) {
			die "error: expected layer directory not found";
		}
		
		$diff_layers_hash->{$layer} = 1;
	}
	
	
	my @directories = glob ($tartemp.'/*');
	
	print "total layers: ".@directories." in $tartemp\n";
	if (@directories == 0) {
		die ;
	}
	
	my $count_keep_layers = 0;
	foreach my $layer_dir (@directories) {
		
		my $dir = basename($layer_dir);
		#my $layer_dir = $tartemp.$dir;
		
		unless (-d $layer_dir) {
			die "layer_dir $layer_dir not found !?";
		}
		
		unless (defined $diff_layers_hash->{$dir}) {
			print "delete non-diff layer directory $layer_dir\n";
			systemp("sudo rm -rf ".$layer_dir);
		} else {
			$count_keep_layers++;
		}
		
	}
	
	if ($count_keep_layers == 0) {
		die "all layers deleted...";
	}
	
	print "create new tar without the base layers\n";
	systemp("cd $tartemp && ls -la") == 0 or die;
	systemp("cd $tartemp && sudo tar -cf $output_tar *") == 0 or die;
	systemp("sudo chmod 666 ".$output_tar);
	
	
	
	
	if (defined($tag) && defined($repo)) {
	
		print "insert tag information into tar\n";
		my $repositories_file_content = "{\\\"$repo\\\":{\\\"$tag\\\":\\\"$image_id\\\"}}";
	
		
		systemp("echo \"$repositories_file_content\" > repositories");
	} else {
		
		die "tag and repo need to be defined --tag=repo:tag"; # TODO can I save without adding file ?
		
	}
	
	
	
	my $py_cmd = "python -c \"import tarfile; f=tarfile.open('".$output_tar."', 'a'); f.add('repositories'); f.close()\"";
	
	
	systemp($py_cmd) == 0 or die;
	
	
	print "gzip tar file\n";
	
	systemp("gzip ".$output_tar)==0 or die;

	unless (-e $output_targz) {
		die;
	}
	
	return $output_targz;
}


sub upload_docker_image_to_shock {
	
	
	my ($token, $image_file, $repo, $tag, $image_id, $base_image_object, $dockerfile, $image_docker_version_hash) = @_;
	### upload image to SHOCK ###
	#check token
	#check server
	
	unless (defined $token) {
		die;
	}
	
	unless (defined $tag) {
		die;
	}
	
	my $repotag = $repo.':'.$tag;
	
	
	require SHOCK::Client;
	
	
	unless (defined($token)) {
		die 'SHOCK token not found';
	}
	
	unless (defined $shock) {
		$shock = new SHOCK::Client($shock_server, $token);
	}
	
	
	my $dockerfile_encoded = '';
	
	if (defined $dockerfile && $dockerfile ne 'none') {
		require MIME::Base64;
		$dockerfile_encoded = MIME::Base64::encode_base64($dockerfile);
		$dockerfile_encoded =~ s/\n//g;
		print "dockerfile_encoded:\n$dockerfile_encoded\n";
	}
	
	
	
	my $node_attributes = {
		"temporary"				=> "1",
		"type"					=> "dockerimage",
		"name"					=> $repotag						|| die,
		"id"					=> $image_id					|| die,
		"docker_version"		=> $image_docker_version_hash	|| die,
		"base_image_tag"		=> $base_image_object->{'name'} || "",
		"base_image_id"			=> $base_image_object->{'id'}	|| "",
		"dockerfile"			=> $dockerfile_encoded			|| ""
	};
	
	my $json = JSON->new;
	my $node_attributes_str = $json->encode( $node_attributes );

	
	
	#print "node_attributes_str:\n$node_attributes_str\n";
	print "node_attributes: ".Dumper($node_attributes) ;
	
	
	print "uploading file \"".$image_file."\" ...\n";
	
	if (defined $h->{'docker_noupload'}) {
		print "--docker_noupload invoked.\n";
		exit(0)
	}
	
	print "upload image to SHOCK docker repository\n";
	my $up_result = $shock->upload('file' => $image_file, 'attr' => $node_attributes_str) || die;
	#same as: my $curl_cmd = 'curl -X POST -H "Authorization: OAuth $GLOBUSONLINE"  -F "attributes=@sodoku_docker.json" -F "upload=@'.$image_tarfile.'" "'.$shock_server.'/node"';
	print Dumper($up_result);
	unless ($up_result->{'status'} == 200) {
		die;
	}
	
	my $shock_node_id = $up_result->{'data'}->{'id'} || die "SHOCK node id not found for uploaded image";
	
	unless (defined $h->{'private'}) {
		$shock->permisson_readable($shock_node_id) || die "error makeing node readable";
	}
	
	print "Docker image uploaded ($shock_node_id).\n";
	
	return $shock_node_id;
	
}

sub create_url {
	my ($endpoint, %query) = @_;
	
	my $my_url = 'http:'.$docker_socket.'/'.$endpoint;
	
	#build query string:
	my $query_string = "";
	
	foreach my $key (keys %query) {
		my $value = $query{$key};
		
		unless (defined $value) {
			if ((length($query_string) != 0)) {
				$query_string .= '&';
			}
			$query_string .= $key;
			next;
		}
		
		my @values=();
		if (ref($value) eq 'ARRAY') {
			@values=@$value;
		} else {
			@values=($value);
		}
		
		foreach my $value (@values) {
			if ((length($query_string) != 0)) {
				$query_string .= '&';
			}
			$query_string .= $key.'='.$value;
		}
	}
	
	
	if (length($query_string) != 0) {
		
		#print "url: ".$my_url.'?'.$query_string."\n";
		$my_url .= '?'.$query_string;#uri_escape()
	}
	
	
	
	
	return $my_url;
}


sub dockerSocket {
	my ($request_type, $endpoint, $query, $headers) = @_;
	
	my $url = create_url($endpoint, %$query);
	
	
	
	print "request: $request_type $url\n";
	
	my @method_args = ($url);
	if (defined $headers) {
		#if (defined $headers->{':content_cb'}){
		#	$is_download = 1;
		#}
		
		push(@method_args, %$headers);
	}
	
	
	my $agent = LWP::UserAgent->new;
	
	require LWP::Protocol::http::SocketUnixAlt;
	LWP::Protocol::implementor( http => 'LWP::Protocol::http::SocketUnixAlt' );
	
	
	my $json = JSON->new;
	my $response_content = undef;
    
    eval {
		
        my $response_object = undef;

		
		if ($request_type eq 'GET') {
			$response_object = $agent->get(@method_args);
		} elsif ($request_type eq 'POST') {
			$response_object = $agent->post(@method_args);
		} else {
			die;
		}
	
		print "content: ".$response_object->content."\n";
		
		my $content_type = $response_object->header('Content-Type');
		
		if (defined $content_type && $content_type eq 'application/json') {
				$response_content = $json->decode( $response_object->content );
		}
	};
	
	
	if ($@) {
		
		if (! ref($response_content) ) {
			print STDERR "[error] unable to connect to socket\n";
			return undef;
		} elsif (exists($response_content->{error}) && $response_content->{error}) {
			print STDERR "[error] unable to send $request_type request to socket: ".$response_content->{error}[0]."\n";
			return undef;
		}
		
	}
	
	print 'response_content: '.Dumper($response_content)."\n";
	

	LWP::Protocol::implementor( http => 'LWP::Protocol::http' );
	
	return $response_content;

}

# check if base image is in shock
sub findImageinShock {
	my ($image_id) = @_;
	
	require SHOCK::Client;
	
	unless (defined $shock) {
		$shock = new SHOCK::Client($shock_server, $ENV{'GLOBUSONLINE'});
	}
	
	my $node_obj = $shock->query('type' => 'dockerimage', 'id' => $image_id);
	print 'node: '.Dumper($node_obj);
	
	my @nodes = ();
	
	if (defined $node_obj->{'data'}) {
		push (@nodes, @{$node_obj->{'data'}});
	}
	
	return @nodes;
}


# get diff layers and check if base is in shock
sub get_diff_layers {
	my ($image_id, $base_id) = @_;
	
	unless (defined $image_id) {
		die;
	}
	
	if (defined $base_id) {
	
		my @base_in_shock = findImageinShock($base_id);
		
		if (@base_in_shock > 1) {
			die "base image multiple times in shock !";
		}
		
		unless (defined $h->{'force_base'}) {
			if (@base_in_shock == 0 ) {
				die "base image not found in shock! upload base first or use --force_base";
			}
		}
	}
	
	my $history = dockerSocket('GET', "/images/$image_id/history");

	my $images = dockerSocket('GET', "/images/json");
	
	
	my $imageid_to_tags={};
	
	my $tag_to_imageid = {};
	foreach my $image_obj (@{$images}) {
		my $id = $image_obj->{'Id'} || die "Id not found";
		my $repotags =  $image_obj->{'RepoTags'} || die "RepoTags not found";
		$imageid_to_tags->{$id} = $repotags;
		
		foreach my $t (@{$repotags}) {
			$tag_to_imageid->{$t}=$id;
		}
	}
	
	
	print "history: ".Dumper($history);
	print "images: ". Dumper($images);
	print Dumper($imageid_to_tags);
	
	
	
	#exit(0);
	my @diff_layers= ();

	unless ($history->[0]->{'Id'} eq $image_id) {
		die "history broken for $image_id ?";
	}
	
	if (defined($base_id)) {
		print "base_id: $base_id\n";
	} else {
		die; # TODO remove
	}
	# check history of image
	my $found_base = 0;
	for (my $i = 0; $i < @{$history}; ++$i) {
		
		my $layer = $history->[$i];
		my $id = $layer->{'Id'};
		unless (defined $id) {
			die;
		}
		
		
		if (defined($base_id) && ($id eq $base_id)) {
			$found_base = 1;
			print "found base id: $base_id\n";
			last;
		}
		
		if (defined $imageid_to_tags->{$id} && ($i > 0)) {
			print $id." layer has image tag: ".join(',', @{$imageid_to_tags->{$id}})."\n";
			
		} else {
			print $id." layer\n";
		}
		
		push(@diff_layers, $id);
		
		
	}

	if (defined($base_id) && ($found_base ==0) ) {
		die "did not find expected base image $base_id in history of $image_id";
	}


	
	print "found ".@diff_layers." diff layers (layers on top of base image) for image ".$image_id."\n";

	if (@diff_layers == 0 ) {
		die;
	}
	
	return @diff_layers;
}

sub addDockerCmd {
	my $docker_line = 'RUN '.join(' ', @_);
	
	if ((@docker_file_content > 0) && ($docker_file_content[-1] eq $docker_line)) {
		return;
	}
	
	
	my $cmd_lines = shift(@_);
	my @cmds = split(/\s*\&\&\s*|\s*\;\s*/,$cmd_lines);
	foreach my $cmd (@cmds) {
		my @cmd_array = split(/\s+/, $cmd);
		my $cmd = $cmd_array[0];
		print "command found: ".$cmd."\n";
		$docker_deps->{$cmd}=1;
	}
	push(@docker_file_content, $docker_line);

	
}

sub systemp {
	print "cmd: ".join(' ', @_)."\n";
	return system(@_);
}

sub system_install {
	print "cmd: ".join(' ', @_)."\n";
	
	if ($d) {
		addDockerCmd(@_);
		
		return 0;
	}
	
	return system(@_);
}

sub modifyINIfile {
	my ($inifile, $ini_hash) = @_;
	
	print "read INI-file $inifile\n";
	
	eval "require Config::IniFiles; 1" # cpanm install Config::IniFiles
	or die "perl module required, e.g.: sudo apt-get install cpanminus ; sudo cpanm install Config::IniFiles";
	
	
	my $cfg = Config::IniFiles->new( -file => $inifile );
	
	foreach my $section (keys %$ini_hash) {
		my $section_hash = $ini_hash->{$section};
		foreach my $key (keys %$section_hash) {
			my $value = $section_hash->{$key};
			
			setINIvalue($cfg, $section, $key, $value);
			
		}
	}
	
	print "write INI-file $inifile\n";
	$cfg->WriteConfig($inifile);
	
}

sub setINIvalue {
	my ($cfg, $section, $key, $value) = @_;
	
	
	if ($cfg->exists($section, $key)) {
		$cfg->setval($section, $key, $value);
	} else {
		$cfg->newval($section, $key, $value);
	}
	
}

#example:[section]key=value?key=value...
sub INI_cmds_to_hash {
	
	my $strings = shift(@_);
	
	my $ini_hash={};
	foreach my $parameter (@{$strings}) {
		my ($section, $pair_string) = $parameter =~ /^\[(\S+)\](.*)$/;
		
		unless (defined($section) && defined($pair_string)) {
			die "could not parse config string: $parameter, required format: [section]key=value";
		}
		
		my @pairs = split('\?', $pair_string);
		if (@pairs == 0) {
			die;
		}
		
		foreach my $pair (@pairs) {
			my ($key, $value) = split('=', $pair);
			unless (defined $key && defined $value) {
				print $parameter." , ".$pair."\n";
				die;
			}
			$ini_hash->{$section}->{$key} = $value;
		}
		
	}
	
	
	return  $ini_hash;
}




sub downloadFile {
	my %args = @_;
	
	my $url = $args{'uri'};
	my $dir = $args{'target-dir'};
	my $targetname = $args{'target-name'};
	#my $output = $args{'output'};

	unless (defined $dir) {
		die;
	}
	
	unless (defined $url) {
		die;
	}
	
	if (substr($dir, -1, 1) ne '/') {
		$dir .= '/';
	}
	
	
	my $file;
	unless (defined $targetname) {
		
		my $basefilename = (split qr{/}, $url)[-1];  # detect filename if possible
		
		unless (defined $basefilename) {
			die "filename could not be detected from url $url";
		}
		
		
		$targetname = $basefilename;
	}
	
	$file = $dir. $targetname;
	
	if (-e $file) {
		if ( (defined($h->{'new'}) ) || (definedAndTrue($args{'remove-existing-file'}) ) ) {
			system_install("rm -f $file");
		} else {
			print "skip file: $file already exists....\n";
			return $file;
		}
	}
	
	
	if ($url =~ /^file\:\/\//) {
		
		my ($localfilename) = $url =~ /^file\:\/\/(.*)$/;
		unless (defined $localfilename) {
			die "died parsing ";
		}
		
		my $localfilename_base = basename($localfilename);
		
		if ($d) {
			
			
			# copy file into build context !
			unless (defined $docker_build_context_dir) {
				$docker_build_context_dir = File::Temp->newdir();
			}
			
			systemp("cp $localfilename $docker_build_context_dir") == 0 or die;
			push(@docker_file_content, "ADD $localfilename_base $file");
			
			
		} else {
			unless (-e $localfilename) {
				die "file not found: $localfilename";
			}
			
			system_install("cp $localfilename $file") == 0 or die;
			
		}
		
		
		
		
		
	} else {
	
	
		
		my $ssl= "";
		if (defined $h->{'nossl'}) {
			$ssl = "--insecure";
		}
		
		
		my $curl_download_cmd = "cd $dir && curl $ssl -L -o $targetname --retry 1 --retry-delay 5 \"$url\"";
		
		my $file_downloaded = 0;
		if ($shock_client_module_available && $d==0) { # TODO use this only for versioned downloads !!!!
			print "try using SHOCK cache\n";
			#check SHOCK
			
			unless (defined $shock) {
				$shock = new SHOCK::Client($shock_server, $ENV{'GLOBUSONLINE'});
			}
			my $download_return = $shock->cached_download($url, $dir, $targetname, $curl_download_cmd);
			
			if (defined $download_return) {
				$file_downloaded = 1;
				print "file downloaded from SHOCK cache\n";
			}
			
			
		}
		
		
		if ($file_downloaded == 0) {
			system_install($curl_download_cmd) == 0 or die;
		} else {
			# file was downloaded from SHOCK cache
			if ($d) {
				#Dockerfile still needs to download it
				addDockerCmd($curl_download_cmd);
			}
		}
	}
	unless (-s $file || $d) {
		die "file $file was not downloaded!?";
	}
	
	#my $fh = File::Temp->new(DIR => $dir, TEMPLATE => 'temp_XXXXXXXXX');
	#my $fname = $fh->filename;
	
	return $file;
	
}

# process global variables
sub process_scalar {
	my $text = shift;
	
	$text =~ s/\$target/$target/g ;
	$text =~ s/\$\{target\}/$target/g ;
	
	$text =~ s/\$\{data_target\}/$data_target/g ;
	
	
	my @variables = ($text =~ m/\$\{(\S+)\}/g);
	
	foreach my $var (@variables) {
		if (defined $ENV{$var}) {
			my $value = $ENV{$var};
			$text =~ s/\$\{$var\}/$value/ ;
		}
	}
	
	
	
	return $text;
}

sub datastructure_walk {
    my %arghash = @_;
	my $datastructure = $arghash{'data'};
	my $sub = $arghash{'sub'}; # function sub will applied to all scalars
	my $arg = $arghash{'subarg'};
	
	my $user_specific = $arghash{'user_specific'} || 0;
	
	my $show=0;
	
	if (ref($datastructure) eq 'HASH') {
		
		
		if ($user_specific == 1 ) {
			### replace keyword names and delete subtrees
			my @keys = keys(%$datastructure);
			foreach my $key (@keys) {
				print "key: $key\n";
				my ($user, $keyword) = $key =~ /^(USER|ROOT)\_(.*)$/;
				if (defined $keyword) {
					
					print "user: $user\n";
					print "keyword: $keyword\n";
					
					if ( ($user eq 'USER' && $is_root_user==0) || ($user eq 'ROOT' && $is_root_user==1) ) {
						$datastructure->{$keyword} = delete $datastructure->{$key};
						print "replace $key with $keyword\n";
					} else {
						delete $datastructure->{$key};
						print "delete $key\n";
					}
				}
				
			}
		}
		
		while (my ($k, $v) = each %$datastructure) {
			if ($show==1) {print "goto $k\n";}
			if (ref($v) eq '') {
				#print "scalar: ".$datastructure->{$k}."\n";
				if (defined $sub) {
					$datastructure->{$k} = $sub->($v, $arg);
				}
				#print "scalar: ".$datastructure->{$k}."\n";
			} else {
				unless (defined($arghash{'nosubpackages'}) && $k eq "subpackages") {
					my %newhash = @_;
					$newhash{'data'} = $v;
					datastructure_walk(%newhash); #'data' => $v, 'sub' => $sub, 'subarg' => $arg
				} else  {
					if ($user_specific == 1 ) {
						my %newhash = @_;
						$newhash{'data'} = $v;
						
						
					}
				}
			}
		}
	} elsif (ref($datastructure) eq 'ARRAY') {
		for (my $i = 0 ; $i < @$datastructure ; $i++ ) {
			if (ref($datastructure->[$i]) eq '') {
				#print "scalar: ".$datastructure->[$i]."\n";
				if (defined $sub) {
					$datastructure->[$i] = $sub->($datastructure->[$i], $arg);
				}
				#print "scalar: ".$datastructure->[$i]."\n";
			} else {
				
				my %newhash = @_;
				$newhash{'data'} = $datastructure->[$i];
			
				datastructure_walk(%newhash); # 'data' => $datastructure->[$i], 'sub' => $sub, 'subarg' => $arg
			}
		}
	
	} elsif (ref($datastructure) ne '') {
		die "got: ".ref($datastructure);
	} else {
		# non-ref scalar !?
		print "scalar: $datastructure\n";
		die;
		
	}
	
	return;
}


sub setenv {
	my ($key, $value) = @_;
	
	if ($d) {
		push(@docker_file_content, "ENV $key $value");
		return;
	}
	
	
	my $envline = "export $key=$value";
	#system_install("grep -q -e '$envline' ~/.bashrc || echo '$envline' >> ~/.bashrc");
	
	bashrc_append($envline);
	
	if ($value =~ /\$/ || $value =~ /\~/) {
		#make sure that environment variables are evaluated
		my $echocmd = "echo \"$value\"";
		$value = `$echocmd`;
		chomp($value);
	}
	
	$ENV{$key}=$value; # makes sure variable can be used even if bashrc is not sourced yet.
	return;
}


sub bashrc_append {
	my $line = shift(@_);
	
	
	my $bashrc = '~/.bashrc';
	
	if ($is_root_user) {
		$bashrc = '/etc/profile';
	}
	
	my $cmd = "grep -q -e '$line' $bashrc || echo '$line' >> $bashrc";
	system_install($cmd);
}


sub git_clone {
	my ($source, $dir, $gitbranch) = @_;
	
	
	my $gitname;
	
	#example git://github.com/qiime/qiime-deploy.git
	#example kbase@git.kbase.us:dev_container
	$gitname = (split(/\/|:/, $source))[-1]; # split on "/" and ":"
	
	if ($gitname =~ /\.git$/) { # remove .git suffix
		($gitname) = $gitname =~ /(.*)\.git/;
	}
		
	unless (defined $gitname){
		die "git string unkown: $source";
	}
	
	my $usebranch="";
	if (defined $gitbranch) {
		#system_install("cd $gitdir && git checkout ".$gitbranch) == 0 or return undef;
		$usebranch = ' -b '.$gitbranch;
	}
	
	
	my $gitdir = $dir.$gitname.'/';
	print "gitdir: $gitdir\n";
	if (-d $gitdir) {
		if (defined $h->{'update'}) {
			system_install("cd $gitdir && git pull") == 0 or return undef;
			return $gitdir;
		}
		if (defined $h->{'new'}) {
			system_install("rm -rf $gitdir") == 0 or die;
		}
	}
	system_install("cd $dir && git clone --recursive $usebranch $source") == 0 or return undef;
	
	
	
	print "git_clone returns $gitdir\n";
	return $gitdir;
}

sub hg_clone {
	my ($source, $dir) = @_;
	
	my $hgname = (split('/', $source))[-1];
	
	unless (defined $hgname) {
		die;
	}
	
	my $hgdir = $dir.$hgname;
	
	if (-d $hgdir) {
		if (defined $h->{'update'}) {
			system_install("cd $hgdir && hg update") == 0 or die;
			return $hgdir;
		}
		if (defined $h->{'new'}) {
			system_install("rm -rf $hgdir") == 0 or die;
		}
	}
	
	system_install("cd $dir && hg clone ".$source) == 0 or die;
	
	return $hgdir;
}


sub get_image_object{
	my ($something) = @_;
	
	my $result_hash = dockerSocket('GET', "/images/$something/json") || die "error: image \"$something\" not found";

	
	print "something: ".Dumper($result_hash);

	my $id =  $result_hash->{'id'} || die "error: id not found in image object";
	
	my $obj = {};
	$obj->{'id'} = $id;
	

	# if user used id to identify image, try to find a tag
	if (lc($something) eq lc(substr($id, 0 , length($something)))) {
	
		my $history = dockerSocket('GET', "/images/".$obj->{'id'}."/history");
		
		print "history: ".Dumper($history);
		
		my $tags = $history->[0]->{'Tags'};
		
		if (! defined($tags) || @$tags == 0) {
			print STDERR "warning: no tag found for image in docker\n";
		}
		
		
		if (defined $tags && @$tags > 0) {
			
			if (@$tags == 1) {
				$obj->{'name'} = $tags->[0];
				
			} else {
			
				my $longest_tag = $tags->[0];
				foreach my $t (@{$tags}) {
					if (length($t) > length($longest_tag)) {
						$longest_tag = $t;
					}
				}
				$obj->{'name'} = $longest_tag;
			}
			
		}
		
	} else {
		# user specified image by its name
		
		$obj->{'name'} = $something;
	}
	
	
	return $obj;
	
}


# replaces ${i} variables
sub replaceArguments {
	my $exec = shift(@_);
	my $package_args_ref = shift(@_);
	
	unless (defined $package_args_ref) {
		$package_args_ref=[];
	}
	
	print "exec: $exec\n";
	print "package_args: ".@$package_args_ref."\n";
	
	
	for (my $i = 0 ; $i < @$package_args_ref; $i++) {
		my $k = $i+1;
		my $j = $package_args_ref->[$i];
		
		#print "j: ".$j."\n";
		$exec =~ s/\$\{$k\}/$j/g;
	}
	
	my $package_args_string = join(' ', @$package_args_ref);
	$exec =~ s/\$\{arguments\}/$package_args_string/g;
	
	
		
	
	print "exec: $exec\n";
	return $exec;
}

sub replaceVersionNumbers {
	my $exec = shift(@_);
	my $version_numbers_ref = shift(@_);
	
	unless (defined $version_numbers_ref) {
		return $exec;
	}
	
	print 'ref: '.ref($version_numbers_ref)."\n";
	
	print "exec: $exec\n";
	print "version_numbers: ".@$version_numbers_ref."\n";
	if (@$version_numbers_ref > 0) {
		for (my $i = 0 ; $i < @$version_numbers_ref; $i++) {
			my $k = $i+1;
			my $j = $version_numbers_ref->[$i];
			
			#print "j: ".$j."\n";
			$exec =~ s/\$\{v$k\}/$j/g;
		}
	} else {
		die;
	}
	print "exec: $exec\n";
	return $exec;
}

sub replacePtarget {
	my $exec = shift(@_);
	my $ptarget = shift(@_);
	
	unless (defined $ptarget) {
		die;
	}
	
	#print 'ref: '.ref($version_numbers_ref)."\n";
	
	#print "replacePtarget_A: $exec\n";
	$exec =~ s/\$\{ptarget\}/$ptarget/g;
	
	#print "replacePtarget_B: $exec\n";
	return $exec;
}


sub commandline_remove_base_layers {
	
	my $image_tarfile = abs_path(shift(@_));
	my $base_image_obj = shift(@_);
	
	unless ($image_tarfile =~ /\.tar$/) {
		die "tar expected";
	}
	
	my ($imagediff_tarfile) = $image_tarfile =~ /^(.*)\.tar$/;
	$imagediff_tarfile .= ".diff.tar";
	
	#my ($repo, $tag)
	
	my $repo = undef;
	my $tag = undef;
	
	if (defined $h->{'tag'}) {
		($repo, $tag) = split(':', $h->{'tag'});
	} else {
		die "error: please define --tag , e.g. --tag=namespace/repo:version";
		
	}
	
	
	my $image_id=undef;
	
	
	
	unless (defined ($image_id)) {
		my $image_tarfile_base = basename($image_tarfile);
		
		my ($parsed_image_id) = $image_tarfile_base =~ /^([0-9A-Fa-f]{64})/;
		if (defined($parsed_image_id)) {
			$image_id = $parsed_image_id;
		}
		
	}
	
	
	unless (defined($image_id)) {
		die "error: image_id unknown\n";
	}
	
	print "use imaged_id: $image_id\n";
	
	my $imagediff_tar_gz = remove_base_from_image_and_set_tag($image_tarfile, $repo, $tag, $image_id, $base_image_obj);
	
	
}


sub parsePackageString{
	my $package_string = shift(@_);
	
	#print "package_string: $package_string\n";
	
	my $package = undef;
	my ($p, $package_arg_line) = $package_string =~ /^(.*)(\(.*\))$/;
	
	my @package_args=();
	if (defined $package_arg_line) {
		$package = $p;
		($package_arg_line)= $package_arg_line =~ /^\((.*)\)$/;
		#print "package_arg_lineB: $package_arg_line\n";
		
		if (defined $package_arg_line && $package_arg_line ne "") {
			@package_args = split(' ', $package_arg_line) ;
		}

		
	} else {
		$package = $package_string;
	}
	
	#print "package_args_got: ".join(',', @package_args)."\n";
	
	
	my $argref = undef;
	if (@package_args > 0) {
		$argref = \@package_args;
	}

	
	my ($p2, $version) = $package =~ /^(.*)\=\=(.*)$/;
	
	if (defined $p2 && defined $version) {
		$package = $p2;
		
		my @version_array = split(/\./, $version); # make it an array_ref
		
		if (@version_array == 0) {
			die "version string parsing failed: \"$version\"";
		}
		
		$version = \@version_array;
		
	} else {
		$version = undef;
	}
	
	
	return ($package, $version, $argref);
	
}


my $functions = {};

# examples:
# https://github.com/wgerlach/amethst/playground
# amethst/playground
# amethst
sub function_kbasemodules {
	my %arghash = @_;
	
	#my $server = $arghash{'server'} or die;
	my $target = $arghash{'target'} or die;
	my $package_list = $arghash{'package-list'} || "";
	
	
	
	
	if (substr($target, -1, 1) ne "/") {
		$target .= '/';
	}
	
	my @kbase_modules = split(' ', $package_list);
	
	my $downloaded_modules = {};
	while (@kbase_modules > 0) {
		my $module = shift(@kbase_modules);
		my @server_list = ('https://anonymous:anonymous@github.com/kbase/', 'kbase@git.kbase.us:');
		
		my ($use_server, $mod) = $module =~ /^(http.?:\/\/github.com\/[a-zA-Z0-9\.\-\_]+\/)(.*)$/;
		
		if (defined $mod) {
			$module = $mod;
			print "use_server: $use_server\n";
			
			# set arbitary password to avoid username prompt
			my $search = 'github.com';
			my $replace = 'anonymous:anonymous@github.com';
			$use_server =~ s/$search/$replace/;
			
			@server_list = ($use_server);
		}
		
		my ($modx, $branch) = split('/', $module);
		
		if (defined $branch) {
			print "branch: $branch\n";
			$module = $modx;
		}
		
		
		unless (defined $downloaded_modules->{$module}) {
			
			
			print "kbase module requested: ".$module."\n";
			
			my $gitdir = undef;
			foreach my $this_server (@server_list) {
				$gitdir = git_clone($this_server.$module, $target, $branch);
				
				if (defined $gitdir) {
					last;
				}
			}
			
			unless (defined $gitdir) {
				die "Could not clone KBase module $module";
			}
			
			$downloaded_modules->{$module} = 1;
			
			my $filename = $gitdir.'DEPENDENCIES';
			if (-e $filename) {
				open my $fh, "<", $filename
				or die "could not open $filename: $!";
				my @deps = <$fh>;
				foreach my $dep (@deps) {
					chomp($dep);
					if ($dep ne '') {
						push(@kbase_modules, $dep);
					}
				}
			}
				
			
			
			
		}
		
	}
	
	
}

$functions->{'kbasemodules'} = \&function_kbasemodules;


sub definedAndTrue {
	my $x = shift(@_);
	if (defined $x && $x == 1) {
		return 1;
	}
	return 0;
}

sub get_array {
	my $ref = shift(@_);
	my @array;
	
	if (ref($ref) eq 'ARRAY' ) {
		@array = @{$ref};
	} else {
		@array = ($ref);
	}
	
	return @array;
}


sub array_execute {
	my ($argument, %replacements) = @_;
	
	
	my @execs;
	if (ref($argument) eq 'ARRAY') {
		@execs = @{$argument};
	} else {
		@execs = ($argument);
	}
	foreach my $exec (@execs) {
		
		foreach my $key (keys(%replacements)) {
			my $value = $replacements{$key};
			if (defined $value) {
				$exec =~ s/\$\{$key\}/$value/g;
			}
		}
		
		unless ($exec =~ /^\#/) {
			print "exec:\n";
			system_install($exec) == 0 or die;
		}
	}
	
}

sub commandline_upload {
	
	my $image_tarfile = shift(@_);
	
	unless (-e $image_tarfile) {
		die;
	}
	
	unless ($image_tarfile =~ /gz$/) {
		die "error: please gzip first";
	}
	
	
	# tag
	my $repo = undef;
	my $tag = undef;
	
	if (defined $h->{'tag'}) {
		($repo, $tag) = split(':', $h->{'tag'});
	} else {
		
		my $image_repo = read_name_from_tar_image($image_tarfile);
		
		
		my @i_repos = keys(%{$image_repo});
		my $i_repo = shift( @i_repos ) || die;
		my $i_repo_hash = $image_repo->{$i_repo};
		my @i_tags = keys(%{$i_repo_hash});
		my $i_tag =  shift(@i_tags)  || die;
		
		print "got: ".$i_repo . ":".$i_tag."\n";
		
		$repo = $i_repo;
		$tag = $i_tag;
		
	}
	
	# dockerfile
	my $dockerfile = $h->{'dockerfile'};
	unless (defined($dockerfile)) {
		die "error: please specify docker file. if not available explicitly specifiy --dockerfile=none";
	}
	
	if ($dockerfile eq 'none') {
		$dockerfile = undef;
	}
	
	if (defined $dockerfile) {
		$dockerfile = read_file($dockerfile);
	}
	
	
	
	
	
		
	
	
	# image history
	my $image_history = read_history_from_tar_image($image_tarfile);
	my $image_history_hash = {};
	
	my @noparents=();
	my $layer_graph_inverse={}; # points to child
	my $layer_graph={};
	foreach my $layer (@{$image_history}) {
		my $id =  $layer->{'id'};
		$image_history_hash->{$id} = $layer;
		if (defined $layer->{'parent'}) {
			$layer_graph_inverse->{$layer->{'parent'}}=$id;
			$layer_graph->{$id} = $layer->{'parent'};
		} else {
			push(@noparents, $id);
		}
	}
	
	if (@noparents > 1) {
		die "baseimages > 1";
	}
	
	#my $baseimage_id = shift(@noparents);
	#print "baseimage_id: $baseimage_id\n";
	
	
	my @leaves=();
	my @parent_leaf=();
	print Dumper($layer_graph_inverse);
	foreach my $layer (@{$image_history}) {
		
		my $id =  $layer->{'id'};
		
		#child
		unless (defined $layer_graph_inverse->{$id}) {
			push(@leaves, $id);
		}
		
		#parent
		my $parent = $layer_graph->{$id};
		if (defined $parent) {
			
			unless (defined $image_history_hash->{$parent}) {
				# parent has ID but is not part of the image
				push(@parent_leaf, $parent);
			}
		}
		
	}
	
	unless (@leaves == 1) {
		die "leaves != 1";
	}
	
	if (@parent_leaf > 1) {
		die "parent_leaf > 1, ".scalar(@parent_leaf);
	}
	
	my $baseimage_id=undef;
	if (@parent_leaf == 1) {
		$baseimage_id = shift(@parent_leaf);
	}
	
	
	my $image_id = shift(@leaves);
	print "image_id: $image_id\n";
	
	
	
	
	
	
	my $image_docker_version = $image_history_hash->{$image_id}->{'docker_version'};
	
	
	
	
	
	my $base_image_object = {};
	
	if (defined $baseimage_id) {
	
		if (defined($h->{'base_image_name'})) {
			
			if ($h->{'base_image_name'} ne 'none') {
				$base_image_object->{'name'} = $h->{'base_image_name'};
				$base_image_object->{'id'} = $baseimage_id;
			} else {
				$base_image_object = undef;
			}
		} else {
			print "base_image_name not defined, try to infer from docker...\n";
			$base_image_object = get_image_object($baseimage_id);
			
			my $err_str = "error: please define --base_image_name, e.g. --base_image_name=ubuntu:13.10";
			
			unless (defined $base_image_object) {
				die $err_str;
			}
			unless (defined $base_image_object->{'id'}) {
				die $err_str;
			}
			unless (defined $base_image_object->{'name'}) {
				die $err_str;
			}
			
			
			
			if ($base_image_object->{'id'} ne $baseimage_id) {
				print STDERR  $err_str."\n";
				print STDERR "error: id not identical \n\"".$base_image_object->{'id'}."\"\n\"".$baseimage_id."\"\n";
				
				#my $a = $base_image_object->{'id'};
				#my $b = $baseimage_id;
				#$a =~ s/(.)/ord($1)/eg;
				#$b =~ s/(.)/ord($1)/eg;
				
				
				
				#print "Ascii a: $a\n";
				#print "Ascii b: $b\n";
				
				#my $c = $a - $b;
				
				#print "diff: $c\n";
				
				exit(1);
			}
			
			
		}
	} else {
		$base_image_object = undef; # no baseimage exists
	}
		
	my $docker_info = {};
	$docker_info->{'Version'} = $image_docker_version; # other info not available from tarball
	
	
	my $shock_node_id = upload_docker_image_to_shock($shocktoken, $image_tarfile, $repo, $tag, $image_id, $base_image_object, $dockerfile, $docker_info);
	
	print "uploaded. shock node id: ".$shock_node_id."\n";
}




sub commandline_docker2shock {
	my ($something,$base_image_object) = @_;
	
	
	unless (defined $base_image_object->{'id'}) {
		die; # TODO remove
	}
	
	#### save image
	print "### save image\n";
	
	my $image_obj = get_image_object($something);
	
	unless (defined $image_obj->{'id'} && defined $image_obj->{'name'}) {
		die ;
	}
	my $image_id = $image_obj->{'id'};

	my $print_name = $image_obj->{'name'};
	$print_name =~ s/[\:\_\/]/\_/g;
	
	
	my ($repo, $tag) = split(':', $image_obj->{'name'});
	
	unless (defined $datadir) {
		die;
	}
	if ($datadir eq '') {
		die;
	}
	
	
	my $image_tarfile = $datadir.$image_obj->{'id'}.'_'.$print_name.'.tar';
	
	save_image_to_tar($image_obj->{'id'}, $image_tarfile);
	
	
	#### modify image (add tags)
	print "### modify image\n";
	my $imagediff_tar_gz = remove_base_from_image_and_set_tag($image_tarfile, $repo, $tag, $image_id, $base_image_object);

	
	##### upload
	print "### upload image\n";
	
	my $shock_node_id = upload_docker_image_to_shock($shocktoken, $imagediff_tar_gz, $repo, $tag, $image_id, undef, undef, get_docker_version());
	
	print "uploaded. shock node id: ".$shock_node_id."\n";
}

sub create_repository {
	my $repo_file = 'repository.json';
	
	if (-e $repo_file) {
		die "Repository file $repo_file already exists. Please delete old first.";
	}
	
	
	my $repository_merge={};
	
	my @error_file=();
	foreach my $file (@ARGV) {
		
		unless (-e $file) {
			die "file \"$file\" not found";
		}
		my $cat_cmd = "cat ".$file." | grep -v ^# ";
		my $repository_json = `$cat_cmd`;
		chomp($repository_json);
		my $repository;
		
		#try {
		$repository = decode_json($repository_json);
		#}
		#catch {
		#warn "caught error: $_"; # not $@
		#print Dumper($repository);
		#	print STDERR "warning: could not parse json in $file\n";
		#	push(@error_file, $file);
		#next;
		#};
		
		foreach my $key (keys(%$repository)) {
			if (defined $repository_merge->{$key}) {
				die "key $key already defined";
			}
			$repository_merge->{$key} = $repository->{$key};
			
		}
	}
	#print Dumper($repository_merge);
	
	my $json = JSON->new;
	my $repository_merge_pretty = $json->pretty->encode( $repository_merge );
	print $repository_merge_pretty ."\n";
	
	open(my $fh, '>', $repo_file);
	print $fh $repository_merge_pretty."\n";
	close $fh;
	
	
	if (@error_file > 0) {
		print "warning: problems with following files:".join(',',@error_file)."\n"
	}
}

sub read_history_from_tar_image {
	
	my ($image_tarfile) = @_;
	
	# extract all jsons: tar -xvOf $image_tarfile --wildcards '*/json'
	#my $tar_extr = "tar -xvOf $image_tarfile ".$image_id.'/json';
	
	my $z;
	
	if ($image_tarfile =~ /\.tar$/) {
		$z = '';
	} elsif ($image_tarfile =~ /\.tar\.gz$/) {
		$z = 'z';
	} elsif ($image_tarfile =~ /\.tgz$/) {
		$z = 'z';
	} else {
		die;
	}
	
	
	
	my $tar_extr = "tar -x".$z."vOf $image_tarfile --wildcards '*/json'";
	
	my $tar_json = '['.`$tar_extr`.']';
	
	# insert commas: TODO this is ugly!
	$tar_json =~ s/\}\{\"id\"/\},\{\"id\"/g;
		
	print "json has: ".$tar_json."\n";
		
	my $json = JSON->new;
	my $tar_hash = $json->decode( $tar_json );
	print Dumper($tar_hash);
	return $tar_hash;
		
}

sub get_docker_version {
	unless (defined $docker_version_info) {
		
		my $result_hash = dockerSocket('GET', "/version");
		unless (defined $result_hash) {
			die;
		}
		$docker_version_info = $result_hash;
	}
	return $docker_version_info;
}

sub read_name_from_tar_image {
	
	my ($image_tarfile) = @_;
	
	# extract all jsons: tar -xvOf $image_tarfile --wildcards '*/json'
	#my $tar_extr = "tar -xvOf $image_tarfile ".$image_id.'/json';
	
	my $z;
	
	if ($image_tarfile =~ /\.tar$/) {
		$z = '';
	} elsif ($image_tarfile =~ /\.tar\.gz$/) {
		$z = 'z';
	} elsif ($image_tarfile =~ /\.tgz$/) {
		$z = 'z';
	} else {
		die;
	}
	
	
	my $tar_extr = "tar -x".$z."vOf $image_tarfile 'repositories'";
	
	my $tar_json = `$tar_extr`;
		
	print "json has: ".$tar_json."\n";
		
	my $json = JSON->new;
	my $tar_hash = $json->decode( $tar_json );
	print Dumper($tar_hash);
	return $tar_hash;
		
}

sub chdirp {
	my $ptarget = shift(@_);
	if ($d) {
		print 'cmd: cd '.$ptarget."\n";
	} else {
		chdir($ptarget);
	}
}

sub install_package {
	my ($repository, $package_hash, $package, $version, $package_args_ref) = @_;
	
	#print 'ref1: '.ref($version)."\n";
	#print "$package: ". Dumper($package_hash);
	
	
	
	if (definedAndTrue($package_hash->{'ignore'})) {
		print STDERR "package $package ignored.\n";
		return;
	}
	
	if (defined $package_hash->{'ignore'}) {
		die;
	}
	
	
	# replace arguments if they have been used
	datastructure_walk('data' => $package_hash, 'sub' => \&replaceArguments, 'subarg' => $package_args_ref);
	
	
	print "install package: $package\n";
	print "args: ".join(' ',@$package_args_ref)."\n" if defined $package_args_ref;
	
	
	unless (defined $package_hash) {
		print STDERR "error: no configuration found for package $package\n";
		exit(1);
	}
	
	# START installation ########################
	#if (defined $already_installed{$package} && $already_installed{$package}==1) {
	if (definedAndTrue($already_installed{$package})) {
		print "package $package already installed, skip it...\n";
		next;
	}
	
	if (defined $version) {
		#print 'ref2: '.ref($package_hash->{'version'})."\n";
		$package_hash->{'version'} = $version;
	}
	if ((defined $package_hash->{'version'}) && ($package ne "subpackage")) {
		#print 'ref3: '.ref($package_hash->{'version'})."\n";
		datastructure_walk('data' => $package_hash, 'sub' => \&replaceVersionNumbers, 'subarg' => $package_hash->{'version'});
	}
	
	my $ptarget = $package_hash->{'ptarget'} || $target;
	
	# package is a data package ?
	if ( defined($h->{'data_target'}) && definedAndTrue($package_hash->{'data'}) ) {
		unless ( defined($package_hash->{'ptarget'}) ) {
			$ptarget = $h->{'data_target'};
			print "ptarget not defined: use data_target\n";
		} else {
			print "ptarget defined: $ptarget\n";
		}
		print "is data package\n";
	} else {
		print "is normal software package\n";
	}
	
	if (substr($ptarget, -1, 1) ne '/') {
		$ptarget .= '/';
	}
	
	#if (defined($package_hash->{'ptarget'})) {
	datastructure_walk('data' => $package_hash, 'sub' => \&replacePtarget, 'subarg' => $ptarget, 'nosubpackages' => 1);
	#}
	
	if (definedAndTrue($package_hash->{'dir'}) && defined($package_hash->{'ptarget'})) {
		die;
	}
	if (definedAndTrue($package_hash->{'dir'})) {
		$ptarget .= $package.'/';
		$package_hash->{'ptarget'} = $ptarget;
	}
	

	unless (-d $ptarget) {
		system_install("mkdir -p ".$ptarget);
	}

	
	#dependencies
	if (defined $package_hash->{'depends'} && ! defined($h->{'nodeps'})) {
		foreach my $dependency (@{$package_hash->{'depends'}}) {
			
			my ($dep_package, $dep_version, $dep_package_args_ref) = parsePackageString($dependency);
			
			if ( definedAndTrue( $already_installed{$package} ) ) {
				print "dependency $dependency already installed\n";
			}else {
				print "install dependency $dependency for $dep_package...\n";
				unless (defined $repository->{$dep_package}) {
					die "package $dep_package not found\n";
				}
				install_package($repository, $repository->{$dep_package}, $dep_package, $dep_version, $dep_package_args_ref);
			}
		}
	}
	
	
		
	chdirp($ptarget);

	
	
	#subpackages
	if (defined $package_hash->{'subpackages'}) {
		my $subpackages =$package_hash->{'subpackages'};
		foreach my $subpackage (@{$subpackages}) {
			if (defined($package_hash->{'ptarget'}) && ! defined($subpackage->{'ptarget'})) { # inherit ptarget
				$subpackage->{'ptarget'} = $package_hash->{'ptarget'};
			}
			print "install subpackage for $package...\n";
			install_package($repository, $subpackage, "subpackage", $version, $package_args_ref); #recursive !
		}
	}
	
	
	chdirp($ptarget);
	
	if ($package_hash->{'depend-function'}) {
		
		foreach my $function_hash (@{$package_hash->{'depend-function'}}) {
			my $function_name = $function_hash->{'name'};
			&{$functions->{$function_name}}(%$function_hash);
		}
		
		
	}
	
	
	if (defined $package_hash->{'source-as-parameter'} && $package_hash->{'source-as-parameter'} ==1) {
		if (defined $package_args_ref) {
			push(@{$package_hash->{'source'}}, @{$package_args_ref});
			print "source total: ".join(',', @{$package_hash->{'source'}})."\n";
		}
	}

	if (defined $package_hash->{'set-env'}) {
		my $env_pairs = $package_hash->{'set-env'};
		foreach my $key (keys %{$env_pairs} ) {
			setenv($key, $env_pairs->{$key}) ;
		}
	}
	
	# resolve short-hand notation
	foreach my $type ('apt', 'pip', 'git', 'go', 'mercurial') {
		if (defined $package_hash->{'source-'.$type}) {
			$package_hash->{'source'} = $package_hash->{'source-'.$type};
			$package_hash->{'source-type'} = $type;
		}
	}
	
	if (defined $package_hash->{'source'}) {
		my @sources = get_array($package_hash->{'source'});
		
		my $build_type = $package_hash->{'build-type'} || 'exec';
		
		my $source_type = $package_hash->{'source-type'} || 'auto';
		
		my $temp_dir_obj = undef;
		my $temp_dir = $ptarget;
		
		if (definedAndTrue($package_hash->{'source-temporary'})) {
			
			if ($d) {
				$temp_dir = '/tmp/sodoku_deploy/';
				system_install('rm -rf '.$temp_dir);
				system_install('mkdir -p '.$temp_dir);
			} else {
				$temp_dir_obj = File::Temp->newdir( TEMPLATE => 'deployXXXXX' );
				$temp_dir = $temp_dir_obj->dirname.'/';
			}
		}
		
		my $source_dir=$ptarget;
		my $source_subdir;
		my $downloaded_file=undef;
		
		foreach my $source_obj (@sources) {
			
			my $source;
			my $source_filename;
			
			my $source_branch;
			if (ref($source_obj) eq 'HASH') {
				$source = $source_obj->{'uri'};
				$source_subdir = $source_obj->{'subdir'};
				$source_filename=$source_obj->{'filename'};
				$source_branch=$source_obj->{'branch'};
			} else {
				$source = $source_obj;
			}
			
			
			# detect source type
			my $st = $source_type;
			if ($st eq 'auto') {
				#autodetect source type
				if ($source =~ /^git:\/\//) {
					$st = 'git';
				} elsif (defined($package_hash->{'git-server'})) {
					$st = 'git';
				} elsif ($source =~ /\@git\./) {
					$st = 'git';
				} elsif ($source =~ /^ssh.*\.git/) {
					$st = 'git';
				} else {
					$st='download';
				}
				
			}
			
			
			
			$source_dir=$ptarget;
			
			if ($st eq 'git' && defined($package_hash->{'git-server'})) {
				$source = $package_hash->{'git-server'}.$source;
			}
			
			
			
			if ($st eq 'git' || $st eq 'mercurial' || $st eq 'go') {
				if (@sources > 1 ) {
					die "only one $st-source per package possible";
				}
				
				
				if ($st eq 'git') {
					$source_dir = git_clone($source, $temp_dir, $source_branch) || die;
				} elsif ($st eq 'mercurial') {
					$source_dir = hg_clone($source, $temp_dir);
				} elsif ($st eq 'go') {
					#-fix -u  github.com/MG-RAST/AWE/...
					
					my $update_works = 0;
					if (defined $h->{'update'}) {
						if (system_install("go get -fix -u ".$source) == 0){
							$update_works = 1;
						}
					}
					
					# try to delete previous repository
					if (defined $h->{'new'}) {
					#rm -rf gopath/src/github.com/
						unless (defined $ENV{'GOPATH'}) {
							die "GOPATH environment variable not found";
						}

						if ($ENV{'GOPATH'} eq '') {
							die "GOPATH environment variable empty";
						}

						
						if (-d $ENV{'GOPATH'} ) {
							my $src_dir = $ENV{GOPATH}.'/src/'.$source;
							print "src_dir: $src_dir\n";
							while (substr($src_dir, -1, 1) eq '.') {
								chop($src_dir);
							}
							while (substr($src_dir, -1, 1) eq '/') {
								chop($src_dir);
							}
							if (-d $src_dir) {
								system_install("rm -rf ".$src_dir);
								sleep(1);
							}
						} else {
							system_install("mkdir -p ".$ENV{'GOPATH'});
						}
						
					}
					
					if ($update_works == 0) {
						system_install("cd ".$ENV{'GOPATH'}." && go get ".$source) == 0 or die;
					}
				} else {
					die "repository type unknown";
				}
			
			} elsif ($st eq 'pip') {
				my $pip_options = "";
				#unless (defined($h->{'root'})) {
				#	$pip_options = " --user ".$ENV{'USER'}; # does not work!
				#}
				my $pip_cmd = "pip install ".$source.$pip_options;
				unless ($is_root_user) {
					$pip_cmd = "sudo ".$pip_cmd;
				}
				system_install($pip_cmd) == 0 or die;
			} elsif ($st eq 'apt') {
				my $apt_cmd =  "apt-get --force-yes -y install ".$source;
				unless ($is_root_user) {
					$apt_cmd = "sudo ".$apt_cmd;
				}
				system_install($apt_cmd) == 0 or die;
			} elsif ($st eq 'download') {
				#simple download
				
				$downloaded_file = downloadFile('uri' => $source,
												'target-dir' => $temp_dir, #$ptarget,
												'target-name' => $source_filename,
												'remove-existing-file' => $package_hash->{'source-remove-existing-file'});
				unless (defined $downloaded_file) {
					die;
				}
				
				
				if (definedAndTrue($package_hash->{'source-extract'})) {
					if ($downloaded_file =~ /\.tar\.gz$/) {
						system_install("tar xvfz ".$downloaded_file." -C ".$temp_dir) ==0 or die;
					} elsif ($downloaded_file =~ /\.tgz$/) {
						system_install("tar xvfz ".$downloaded_file." -C ".$temp_dir) ==0 or die;
					} elsif ($downloaded_file =~ /\.zip$/) {
						system_install("unzip ".$downloaded_file." -d ".$temp_dir) ==0 or die;
					} elsif ($downloaded_file =~ /\.tar\.bz2$/) {
						
						my ($tarfile) = $downloaded_file =~ /^(.*)\.bz2$/;
						defined($tarfile) or die;
						system_install("rm -f ".$tarfile);
						system_install("bzip2 -d ".$downloaded_file) ==0 or die;
						
						unless (-e $tarfile || $d) {
							die "tarfile \"$tarfile\" not found";
						}
						
						system_install("tar xvf ".$tarfile." -C ".$temp_dir) ==0 or die;
						
						
					} elsif ($downloaded_file =~ /\.gz$/) {
						my ($uncompressed) = $downloaded_file =~ /^(.*)\.gz$/;
						if (defined $h->{'new'}) {
							system_install("rm -f ".$temp_dir.$uncompressed);
						}
						
						system_install("gzip -d ".$downloaded_file) ==0 or die;
						
						
						
					} else {
						die "unknown archive: $downloaded_file";
					}
					$source_dir=$temp_dir;
				}
				
			} else {
				die "source_type \"$st\" unknown";
			
			}
			
		} # end @sources
	
		
		my $build_dir = $source_dir;
		
		if (defined $source_subdir) {
			
			if (@sources > 1 ) {
				die "source_subdir: not sure that this makes sense";
			}
			
			$build_dir .= $source_subdir;
		}

		if (substr($build_dir,-1,1) ne '/') {
			$build_dir .= '/';
		}
		
		chdirp($build_dir);
		
		### BUILD INSTRUCTIONS ###
		
		# different build-types
		if (defined($package_hash->{'build-exec'})) {
			
			print "sourcedir: $source_dir\n";
			
			if (@sources > 1 ) {
				array_execute($package_hash->{'build-exec'});
			} else {
				array_execute($package_hash->{'build-exec'}, 'source-file' => $downloaded_file, 'source-dir' => $source_dir);
			}
		} elsif ($build_type eq 'make-install' || $build_type eq 'make'){
			
			if (@sources > 1 ) {
				die "make/make-install: not sure that this makes sense";
			}
			
			# change directory if needed
			#if (! -e $build_dir.'configure' && -e $build_dir.'Makefile' ) {
			#	opendir my $dir, "/some/path" or die "Cannot open directory: $!";
			#	my @files = readdir $dir;
			#	closedir $dir;
			#	print join(',', @files)."\n";
			#	die;
			#
			#}
			
			
			
			
			if (-e $build_dir.'configure') {
				system_install("cd $build_dir && ./configure --prefix=$ptarget") == 0 or die;
			}
			
			if (-e $build_dir.'Makefile' || $d) {
				system_install("cd $build_dir && make")== 0 or die; #TODO make -j4
			} else {
				die "Makefile in $build_dir not found";
			}
			if ($build_type eq 'make-install') {
				if (-e $build_dir.'Makefile'  || $d) {
					system_install("cd $build_dir && make install")== 0 or die; #TODO make -j4
				} else {
					die "Makefile in $build_dir not found";
				}
			}
			
		} else {
			# no build
		}
		
		
		### INSTALL INSTRUCTIONS ###

		foreach my $inst_type ('copy', 'binary') {
			if (defined($package_hash->{'install-'.$inst_type})) {
				print "install-type: ".$inst_type."\n";
				my @install_files_array = get_array($package_hash->{'install-'.$inst_type});
				
				my $install_target = $ptarget;
				
				if ($inst_type eq 'binary') {
					if ($is_root_user || $d) {
						$install_target = '/usr/local/bin/';
					} else {
						$install_target = $ENV{"HOME"}.'/bin/';
					}
					system_install('mkdir -p '.$install_target);
					
				}
				
				unless (defined $build_dir) {
					die;
				}
							
				foreach my $install_file (@install_files_array) {
					
					system_install('cp -f '.$build_dir.$install_file.' '.$install_target) == 0 or die;
					
					if ($inst_type eq 'binary') {
						system_install('chmod +x '.$install_target.$install_file) == 0 or die;
					}
					
				}
	
			}
		}
		
		
		
		
		
		if (definedAndTrue($package_hash->{'source-temporary'})  && $d) {
			system_install('rm -rf '.$temp_dir)
		}
		
		chdirp($ptarget);
		#temp_dir goes out of scope here

	}


	
	
	
	if (defined($package_hash->{'set-ini-values'})) {
		
		print "set-ini-values\n";
		
		my $inifile = $package_hash->{'set-ini-values'}->{'file'};
		unless (defined $inifile) {
			die "INI-file $inifile not defined";
		}
		
		unless (-e $inifile || $d) {
			die "INI-file $inifile not found";
		}
		
		
		my $cfg_string = $package_hash->{'set-ini-values'}->{'cfg-string'} || "";
		
		if ($cfg_string ne "") {
			
			print "cfg_string: \"$cfg_string\"\n";
			
			my @cfg_strings = split(' ', $cfg_string);
			
			my $ini_hash = INI_cmds_to_hash( \@cfg_strings );
			modifyINIfile($inifile, $ini_hash)
		}else {
			print STDERR "warning: cfg_string emtpy, will not modify $inifile\n";
		};
		
	}
	
	if (defined $package_hash->{'bashrc-append'}) {
		my @lines;
		if (ref($package_hash->{'bashrc-append'}) eq 'ARRAY') {
			@lines = @{$package_hash->{'bashrc-append'}};
		} else {
			@lines = ($package_hash->{'bashrc-append'});
		}
		foreach my $line (@lines) {
			bashrc_append($line) ;
		}
		
	}
	
	
	if (defined $package_hash->{'exec'}) {
		array_execute($package_hash->{'exec'});
	}
	
	if (defined $package_hash->{'test'}) {
		print "test_exec:\n";
		system_install($package_hash->{'test'}) == 0 or die;
	}
	

	unless ($package eq "subpackage") {
		$already_installed{$package} = 1;
	}
	
	#if (defined $package_hash->{'finish-package'}) {
	#	if (ref($package_hash->{'finish-package'}) eq 'ARRAY' ) {
	#		return $package_hash->{'finish-package'};
	#	} else {
	#		return ($package_hash->{'finish-package'});
	#	}
	#}
	

	if (defined $package_hash->{'version'}) {
		return $package_hash->{'version'};
	}
	
	return undef;
}

#############################################################

print "deploy arguments: ".join(' ', @ARGV)."\n";


my $help_text;
($h, $help_text) = &parse_options (
'name' => 'SODOKU deploy software',
'version' => '1',
'synopsis' => 'deploy_software.pl --target=. package1 package2',
'examples' => 'ls',
'authors' => 'Wolfgang Gerlach',
'options' => [
'deploy:',
	['target=s',			''],
	['data_target=s',		'different target for packages marked with data=1'],
	['update',				'to update existing packages if possible'],
	['new',					'delete packages before cloning'],
	['root',				''],
	['all',					'to install all packages in repository'],
	['repo_file=s',			''],
	['repo_url=s',			''],
	['ignore=s',			'ignore packages'],
	['forcetarget',			'create target directory if not existing'],
	['list',				'list all SODOKU packages'],
	['nodeps',				'do not install dependencies'],
	['nossl',				''],
	'',
'update SODOKU repository file:',
	['create',				'write repository.json by merging multiple json files'],
	'',
'create docker image:',
	['docker',				'create docker image from SODOKU package'],
	['base_image=s',		'specify base_image to build from, e.g. ubuntu:13.10'],
	['docker_reuse_image',	''],
	['private',				'do not make image public on shock server'],
	['tag=s',				'specifiy image name, e.g. me/mytool:1.0.1'],
	['force_base',			'force upload of image even if baseimage is not in shock'],
'',
'save image to tar:',
	['save_image=s',		'save image in tar file'],
'',
'remove base layers:',
	['remove_base_layers=s', 'combine with --base_image and --tag'],
'',
'upload image to shock:',
	['upload=s',			'upload tar-balled image to shock'],
	['dockerfile=s',		'(required) specify dockerfile used to create image, possible:none'],
	['base_image_name=s',	'required if not retrievable from docker, possible:none'],
	['docker_noupload',		''],
	['token=s',				'SHOCK token for image upload'],
'',
'docker2shock',
	['docker2shock=s',		'upload image from docker to shock, this does not remove the baseimage!']
]);

if ($h->{'help'} || keys(%$h)==0) {
	print $help_text;
	exit(0);
}


if (defined $ENV{'GLOBUSONLINE'} && $ENV{'GLOBUSONLINE'} ne '') {
	$shocktoken = $ENV{'GLOBUSONLINE'};
}

if (defined $ENV{'KB_AUTH_TOKEN'} && $ENV{'KB_AUTH_TOKEN'} ne '') {
	$shocktoken = $ENV{'KB_AUTH_TOKEN'};
}

if (defined $h->{'token'}) {
	$shocktoken = $h->{'token'};
}


my $base_image_object = undef; # containes name and id ! 'ubuntu:13.10';
if (defined($h->{'docker'}) ) {
	$d = 1;
	
	unless (defined($h->{'base_image'})) {
		die "please define --base_image, e.g. --base_image=ubuntu:13.10";
	}
}

if (defined($h->{'base_image'})) {
	$base_image_object = get_image_object($h->{'base_image'});
	unless (defined $base_image_object->{'id'} && defined $base_image_object->{'name'}) {
		die ;
	}
}


if (defined($d) && ($d == 1)) {
	
	
	
	eval {
		require SHOCK::Client;
		SHOCK::Client->import();
		$shock_client_module_available = 1;
		print "using SHOCK::Client\n";
		1;
	} or do {
		my $error = $@;
		print "not using SHOCK::Client : $error\n";
	};

	if ($shock_client_module_available == 0) {
		die "error: docker image upload to SHOCK requires module SHOCK::Client";
	}
	
	eval {
		require File::Slurp;
		File::Slurp->import();
		1;
	} or do {
		my $error = $@;
		print "not using File::Slurp: $error\n";
	};
}



if (defined($h->{'upload'})) {
	commandline_upload($h->{'upload'});
	exit(0);
}




if (defined($h->{'remove_base_layers'})) {
	commandline_remove_base_layers($h->{'remove_base_layers'}, $base_image_object);
	exit(0);
}


if (defined $h->{'docker2shock'}) {
	
	unless (defined $base_image_object->{'id'}) {
		die;
	}
	
	commandline_docker2shock($h->{'docker2shock'}, $base_image_object);
	exit(0);
}


if (defined $h->{'save_image'}) {
	
	my $image_obj = get_image_object($h->{'save_image'});
	
	unless (defined $image_obj->{'id'} && defined $image_obj->{'name'}) {
		die ;
	}
	
	my $name  = $image_obj->{'name'};
	$name =~ s/[\:\_\/]/\_/g;
	
	my $filename = $image_obj->{'id'}.'_'.$name.'.tar';
	
	save_image_to_tar($image_obj->{'id'}, $filename);
		
	exit(0);
}

if (defined $h->{'create'}) {
	create_repository();
	exit(0);
}




if (defined $h->{'update'} && defined $h->{'new'} ) {
	die;
}



if ($d) {
	$is_root_user = 1;
} else {
	$is_root_user = ($< == 0)?1:0;
	
	if ( ! defined($h->{'root'}) && $is_root_user ) {
		print "error: please do not run me as root unless you know what you are doing.\n";
		exit(0);
	}

	if (defined($h->{'root'}) &&  ! $is_root_user) {
		print "error: you gave option --root but you are not root.\n";
		exit(0);
	}

}
#my $target = "/kb/runtime/";

# in case we use cached installation
#maybe add to .bashrc : source /home/ubuntu/data/qiime_software/activate.sh

#cd data && wget ftp://ftp.metagenomics.anl.gov/data/misc/private/wolfgang_epaghsmh/qiime_software.tar.gz


if (defined $ENV{'TARGET'} ) {
	$target = $ENV{'TARGET'};
}

if (defined $h->{'target'}) {
	$target = $h->{'target'};
}




unless (defined $target) {
	die "--target needs to specified"; # TODO make package specific !
}

if (substr($target, -1, 1) ne "/") {
	$target .= "/";
}

if (defined($h->{'forcetarget'}) && ! -d $target) {
	system_install("mkdir -p ".$target);
}

if (defined $target) {
	unless (-d $target  || $d) {
		die "target \"$target\" not found!\n";
	}
} else {
	die;
}

if (defined $h->{'data_target'}) {
	$data_target = $h->{'data_target'};
	if (substr($data_target, -1, 1) ne "/") {
		$data_target .= "/";
	}
} else {
	$data_target = $target;
}



my $repository_json = <<'EOF';
{
	xxxxx
}
EOF

#my $package_rules = decode_json($package_rules_json);
my $repository = undef;


my $use_repository;

if (defined $h->{'repo_file'}) {
	$use_repository = $h->{'repo_file'};
	my $cat_cmd = "cat ".$use_repository;
	$repository_json = `$cat_cmd`;
	chomp($repository_json);
} else {
	if (defined $h->{'repo_url'}) {
		$use_repository = $h->{'repo_url'};
	} else {
		$use_repository = $default_repository;
	}
	
	print "fetching repository: ".$use_repository."\n";
	my $curl_cmd = "curl -S -s -o /dev/stdout ".$use_repository;
	$repository_json = `$curl_cmd`;
	chomp($repository_json);

}



print $repository_json."\n";

eval {
	$repository = decode_json($repository_json);
	1;
};
if ($@) {
	my $e = $@;
	print "$e\n";
	exit(1);
}

datastructure_walk('data' => $repository, 'sub' => \&process_scalar, 'user_specific' => 1); # for my "environment variables"... ;-)



my @package_list = @ARGV;

print "target: $target\n";


if (defined($h->{'ignore'})) {
	my @ignorepackages = split(',', $h->{'ignore'});
	foreach my $p (@ignorepackages) {
		if (defined($repository->{$p})) {
			$repository->{$p}->{'ignore'} = 1;
			print "ignore package $p requested\n";
		} else {
			die "package $p not found";
		}
	}
}


if (defined($h->{'list'})) {
	print "list of packages in repository:\n".join(',', keys(%$repository))."\n";
	exit(0);
}


my @packages_installed=();
foreach my $package_string (@package_list) {
	
	my ($package, $version, $package_args_ref) = parsePackageString($package_string);
	
	my $pack_hash = $repository->{$package};
	unless (defined $pack_hash) {
		#print "repository:\n";
		foreach my $p (keys(%$repository)) {
			print "$p\n";
		}
		print "\n";
		
		die "package $package not found\n";
	}
	
	my $used_version = install_package($repository, $pack_hash, $package, $version, $package_args_ref);
	push(@packages_installed,[$package, $used_version] );
}


if ($d) {
	
	unless (defined $base_image_object->{'id'}) {
		die; # TODO remove
	}
	
	
	
	if (@packages_installed > 1) {
		die "not supported";
	}
	
	my $repo=undef;
	my $tag=undef;
	
	if (defined $h->{'tag'}) {
		($repo, $tag) = split(':', $h->{'tag'});
		print "version: $repo, $tag\n";
		
		unless (defined $tag) {
			die "version not defined in --tag repo:ver";
		}
		if ($tag eq '') {
			die "version not defined in --tag repo:ver";
		}
		#my @ver = split(/\./, $version);
		#print "got: ".join('-', @ver )."\n";
		#$version = \@ver;
		
		#print "got: ".join('-', @{$version} )."\n";
		#exit(0);
	} else {
		
		my ($package, $version_array_ref) = @{shift(@packages_installed)};
		$repo = 'wgerlach/'.$package;
		$tag = join('.', @{$version_array_ref});
		
	}
	
	
	
	
	
	
	# docker info
	my $docker_info = dockerSocket('GET', "/info");
	unless (defined $docker_info) {
		die;
	}
	print Dumper($docker_info);
	
	
		
	
	# create Dockerfile
	my $dockerfile = createDockerFile($base_image_object->{'name'});
	
	
	
	# create docker image
	my $ref = createDockerImage($repo, $tag, $dockerfile, $base_image_object);
	my ($image_tarfile, $image_id) = @{$ref};
	
	
	# upload docker image
	
	my $shock_node_id = upload_docker_image_to_shock($shocktoken, $image_tarfile, $repo, $tag, $image_id, $base_image_object, $dockerfile, get_docker_version()) || die;
	
	print "uploaded. shock node id: ".$shock_node_id."\n";
}


unless ($d) {
	print "all packages installed.\n";
}









